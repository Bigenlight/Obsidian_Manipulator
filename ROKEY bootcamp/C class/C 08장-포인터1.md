---
Title: C 08장-포인터
tags: 
NeedCheck: 
Review: 
비고:
---
[[C 이론]]
#C언어
2024-08-07


![[C_4-2차.pdf]]
[22. 메모리 구조 이해(2) - YouTube](https://www.youtube.com/watch?v=kJrzPKRFxBU)
2:00:00 부근 부터
# 포인터
간접적으로 메모리 공간에 간섭 가능
![[Pasted image 20240813221802.png|400]]

###### 포인터 변수 선언 - 이 변수 안에 메모리 주소에 담는겨
(자료형)*  (변수명)  =  (값);
변수에 담을 메모리 주소가 아직 없으면 NULL 값으로 초기화해도 됨
![[Pasted image 20240813223153.png|150]]
(NULL 쓰려면 \#include <stddef.h> 하면 됨)

메모리 주소 길이는 하드웨어와 운영체제에 따라 다름.

간접 참조 연산자 '\*\'
포인터 변수에  '\*'를 붙이면 그때 메모리 주소에 위치한 값에 접근 가능.

![[Pasted image 20240813225103.png]]
첫 줄에서 먼저 포인터 변수를 선언함. 메모리의 주소는 1000임.
두 번째 줄에서 값을 변수에 \*을 통해 넣음.
세 번째 줄은 그냥 변수 속에 있던 값을 다른 변수에 넣는 것.
![[Pasted image 20240813225321.png|500]]
여기서 주목할 것은 주소 그냥 1000임. 그 주소가 변수 ptr안에 있는 것.

나중에 그냥 값을 참조할 때 ==\*은 변수 앞에 옴.==
###### ==ㄴㄴ 그냥 항상 변수 앞에 오는 듯==

이때 포인터 주소를 지정하고 싶을 때 막 지정할 수는 없고
앞에 ==(TYPE*)를 붙이면 **주소 자료형**==으로 형 변환 됨.
![[Pasted image 20240813231318.png|500]]
()를 뒤에 변수랑 붙여서 많이 쓰는 듯.

![[Pasted image 20240813225540.png|270]]
다양한 타입 지원. 초기화를 NULL로 하면 알아서 하는 듯.

포인터 예시:
![[Pasted image 20240813225735.png]]
이제 n을 출력하면 3이 나옴.
![[Pasted image 20240813225840.png|400]]

###### 주소 형변환 할당
![[Pasted image 20240813231605.png]]
ptr1와 prt2 둘다 같은 주소를 가르침.

###### 정수를 메모리에 저장한 후 바이트 단위로 출력
![[Pasted image 20240813232502.png]]
16진수로 값을 저장한 다음에
그 첫 바이트인 3만 가져옴.
![[Pasted image 20240813232614.png|500]]
ptr2는 맨 앞 비트만 봄. 원래 주소란 메모리 맨 앞임.

역순 출력
![[Pasted image 20240813232648.png]]
prt2가 맨 앞 한자리만 가르치니, 1식 늘려서 출력하면 됨. 
sizeof(int)는 원래 int 변수의 크기가 이 메모리의(여기서는 배열이라 생각하면 편함) 크기이기 때문.

char* 이면 int\*와 다르게 바이트 단위로 접근하는건가?

###### 놀랍게도
![[Pasted image 20240813233146.png|400]]
\*의 정확한 위치는 상관이 없는 듯, ==그냥 변수 앞==에만 있으면 됨.
==원래 TYPE* 뒤 딱 붙여서 선언했는데 앞으로 그냥 변수 앞에 붙이는 것으로 통일 ㄱㄱ.==


![[Pasted image 20240813233450.png|300]]
이 방법으로 포인터 선언 양식을 만들고 그 뒤 부터 \*을 안붙여도 되게 만듬.

[[C 09장-포인터2]]
