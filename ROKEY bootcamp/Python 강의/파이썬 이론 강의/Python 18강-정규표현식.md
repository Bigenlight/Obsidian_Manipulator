---
Title: Untitled
tags: 
NeedCheck: 
Review: 
비고:
---
[[Python 이론]]
[[18회차 실습]]
![[ROKEY bootcamp/Python 강의/파이썬 이론 강의/attachments/Python-18.pdf]]
## 코루틴
코루틴은 함수이긴 한데, 원래 함수는 한번 실행하면 갔다오고 그대로 끝나는 반면, 코루틴은 갔다가 돌아왔다 다시 갈 있음. 꺼지지 않는 함수라고 해야하나? 계속 왔다갔다 할 수 있는 병렬적으로 시행 되는 함수라고 봐야함. 스레드랑은 다름. 완전히 병렬 실행은 아니고, 함수의 내용이 남아있는 상태로 계속 왔다갔다 하는 형태임.
![[Pasted image 20240731222419.png|370]]
![[Pasted image 20240731222434.png|370]]

그래서 어떻게 왔다갔다하냐?
제네레이터에서 쓴 yield를 함수 안에 배치하기만 하면 끝!
변수 = (yield)
이것말고 배치 방법이 더 있긴함

밖에서 사용법
변수  = 함수명()
next(변수)
변수.send(함수에 보낼 매개변수 내용)
![[Pasted image 20240731222842.png|230]]
참고 send를 쓰면 무조건 하나의 값을 보내야함.
하지만 (yield) 앞에 굳이 변수는 안써도 ㄱㅊ.

![[Pasted image 20240731223001.png|450]]
위 그림 처럼 왔다 갔다 하는 구조

참고로 next의 존재도 필수임. 얘가 함수 속 yield까지 진행을 시킴.
print(next( - ))로 반환도 가능.
![[Pasted image 20240731223517.png|500]]

#### 코루틴 종료
###### close
밖에서
변수.close()로 종료도 시킬 수 있음. 이러면 강제 종료 됨.

종료 되면 함수 안에 에러를 발생시켜 탈출하는데, 이걸 이용하여 코루틴 함수가 닫힐 때 무언가를 명령하게 만들 수 있음.
![[Pasted image 20240731223553.png|500]]

###### throw
밖에서
변수.throw(예외 이름, 에러 메시지)를 통해 close랑 마찬가지로 오류를 일으켜 중단 시킬 수 있음. 근데 클로즈에서 나아가 에러명과 출력할 값까지 편집 가능.
![[Pasted image 20240731223851.png|400]]
![[Pasted image 20240731223910.png|500]]

#### 하위 코루틴
yield from 하위코루틴명() 을 통해 하위 코루틴 이용 가능.
![[Pasted image 20240731224023.png|500]]
밖에서 send()를 하면 yield from을 거쳐 하위 코루틴까지 직접 전달 됨.
밖에서 for을 통해 하위 코루틴에 값을 직접 주며 반복을 계속 시킴.
for문이 끝나고 none을 보내면 그때 return이 raise StopeIteration를 일으켜 그냥 코루틴에 값을 반환함.

추가 문제 애매한 함수 정의
![[Pasted image 20240731163001.png|400]]


## 정규표현식
문자열에서 패턴을 가져오는 것
![[Pasted image 20240731165153.png]]

참고 사이트:
[08-2 정규 표현식 시작하기 - 점프 투 파이썬](https://wikidocs.net/4308)

> [!파이썬 팁:]
> r' 문자열 \\n '
>  여기 앞에 r(raw string이 붙으면) 뒤에는 특수기호 상관없이 무조건 문자열로 읽음.
>  정규표현식에서 자주 쓰임

#### import re
로 사용 가능
### re.match()
re.match( 패턴, 문자열)로 검사 가능
근데 아쉽게도 일반 match로는 시작 부분에서 부터 나타나는 패턴만 판별 가능.
뒤에 까지 보려면 앞에서 무시할 문자열을 작성해야 됨.

안에 없다면 아무것도 반환 안됨.

```python
변수 = re.match( _ , _ )
if 변수:
	print(f"{변수}")
```
위에 처럼 match()를 어디에 할당했을 때
이거를 if 문 앞에 두면 T/F 출력이 되고
출력하면 내용물이 나옴.(예시: <re.Match object; span=(10, 16), match='sample'>)

###### OR
찾는 문자열 안에 or ( | )를 집어 넣으면 둘중 하나만 있어도 반환 됨.
###### \*와 +
뒤에 \*이 붙으면 그 바로 앞에 있는 것이 0개 이상일때 인식, 이게 뭔소리냐면 그냥 있든 없든 상관 노. 일단 인식을 시킴. (나중에는 다른거 들오면 안되는 것 같기도)
![[Pasted image 20240731173923.png|400]]
![[Pasted image 20240731174409.png|370]]
위에는 인식이 되지만, 아래는 안됨.
![[Pasted image 20240731174451.png|370]]

'+'는 하나 이상이 있어야 발동.
물론 둘다 맨앞 기준 부터.
![[Pasted image 20240731174156.png|320]]

###### ?와 .
![[Pasted image 20240731174644.png|600]]
abc?d인 경우 abcd와 abd는 되지만 abzd는 안됨. \*랑 비슷 한 듯
![[Pasted image 20240731174952.png|370]]
. 은 그 자리에 아무 문자가 들어와도 ㄱㅊ. 한자리만 딱들어오면 됨.
하지만 안들어오면 발동 노.

###### 문자{개수}
이런식으로 맨앞 기준으로 개수만큼 연속 돼서 맞는 것을  찾을 수 있음.
\[0-9]{3} 이런식으로 이 번호 안에 몇개가 연속으로 들어올지도 찾기 가능.
![[Pasted image 20240731175541.png|500]]
\[0-9]{3,7} 이렇게 개수의 범위도 지정 가능.

###### 범위
\[a-zA-Z0-9] 참고로 이 것의 뜻은 소문자/대문자 a 부터 z와 숫자 다 되는 것이다.
한국어로는 가-힣 하면 됨.

###### 제외 \[^문자]
\[] 안에 ^를 적어놓으면 그 후 문자열 제외를 가져옴(물론 처음 것만). 
![[Pasted image 20240731191858.png|350]]
하지만 이렇게 뒤에 개수 적으면 여러개 가능

==주의! search()에서 ^를 앞에 써서 맨 앞 부터 검사하는거랑 다름! 맨 앞 검사는 ^\[]이고 제외는 \[^]임!== 
반대로 뒤에 부터 검사는 \[ ]\*$로 가능. 

###### 문자 판단 단축 명령
![[Pasted image 20240731193208.png|600]]


### re.search()
![[Pasted image 20240731165611.png]]
비슷한 방식으로 서치가 있음.
맨앞뒤 상관 없이 문자열을 찾음. 가장 앞에 있는 것 만
![[Pasted image 20240731165800.png|300]]
span으로 반환 되는 것은 인덱스임.(인데스가 6이라는)

하지만 문자열에 ^나 $를 붙이면
맨앞이나 맨뒤를 한번만 봄. 즉, 위의 같은 경우 o는 못 찾음

re.findall(*)

문제가 다 꽤 어려움