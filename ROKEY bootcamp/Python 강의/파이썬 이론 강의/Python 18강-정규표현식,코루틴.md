---
Title: Untitled
tags: 
NeedCheck: 
Review: 1회
비고: 처음 배움
---
[[Python 이론]]
[[18회차 실습]]
![[ROKEY bootcamp/Python 강의/파이썬 이론 강의/attachments/Python-18.pdf]]
## 코루틴
코루틴은 함수이긴 한데, 원래 함수는 한번 실행하면 갔다오고 그대로 끝나는 반면, ==코루틴은 갔다가 돌아왔다== 다시 갈 있음. 꺼지지 않는 함수라고 해야하나? 계속 왔다갔다 할 수 있는 병렬적으로 시행 되는 함수라고 봐야함. 스레드랑은 다름. 완전히 병렬 실행은 아니고, 함수의 내용이 남아있는 상태로 계속 왔다갔다 하는 형태임.
![[Pasted image 20240731222419.png|370]]
![[Pasted image 20240731222434.png|370]]

그래서 어떻게 왔다갔다하냐?
[[Python 17강-이터&제네리터]]
제네레이터에서 쓴 ==yield==를 함수 안에 배치하기만 하면 끝!
변수 = (yield)
이것말고 배치 방법이 더 있긴함

밖에서 사용법
==변수  = 함수명()==
==next(변수)==

==변수.send(함수에 보낼 매개변수 내용)==
![[Pasted image 20240731222842.png|230]]
참고 send()를 쓰면 무조건 ()안에 하나의 값을 보내야함.
하지만 (yield) 앞에 굳이 변수는 안써도 ㄱㅊ.

![[Pasted image 20240731223001.png|450]]
위 그림 처럼 yield와 send로 왔다 갔다 하는 구조

참고로 next의 존재도 필수임. 얘가 함수 속 yield까지 진행을 시킴.
print(next( - ))로 반환도 가능.
![[Pasted image 20240731223517.png|500]]

###### 복습
![[Pasted image 20250210175239.png|500]]
메모리도 유지된다. 처음 선언할 때는 아무 것도 실행 안됨.
![[Pasted image 20250210175316.png|300]]
참고로 <span style="background:rgba(240, 200, 0, 0.2)">next( 제너레이터 객체(generator object) )</span> 는 필수적인 존재.

그리고 꼭 .send()를 사용할 필요가 없다 (보낼 변수가 없다면)
![[Pasted image 20250210175820.png|200]]
![[Pasted image 20250210175758.png|200]]
그냥 받는 자리에에 none 뜸

###### 참고로 코루틴에서는 return 대신에 yield로 값을 반환하는데
![[Pasted image 20250210180945.png|400]]
![[Pasted image 20250210181003.png|200]]
이게 next를 send 사이에 안 넣으면 다음 보내는 **값이 씹히는** 것 같다. 
이유는 간단하다. **코루틴에서는 yield가 있을 때마다 함수 동작은 멈추고 밖으로 나온다.**
즉, 지금 저기 위에서는 yield를 다른 방식이지만 **두 번** 사용 했으니, 예상치 못 한 곳에서 나오는 것이다. 그리고 위는 next를 사용해서 해결한 거고.

조금 더 깔끔한 해결 방법이 있다.
![[Pasted image 20250210181847.png|500]]
![[Pasted image 20250210181911.png|400]]
이런 식으로 쓰면 **반환과 값 받기를 동시에 실행한다!!!!**
yield를 한번만 쓰고도 값을 받고 내보내는 것이 완성!!


#### 코루틴 종료
###### close
밖에서
변수.close()로 종료도 시킬 수 있음. 이러면 강제 종료 됨.

종료 되면 함수 안에 에러를 발생시켜 탈출하는데, 이걸 이용하여 코루틴 함수가 닫힐 때 무언가를 명령하게 만들 수 있음.
![[Pasted image 20240731223553.png|500]]

###### throw
밖에서
변수.throw(예외 이름, 에러 메시지)를 통해 close랑 마찬가지로 오류를 일으켜 중단 시킬 수 있음. 근데 클로즈에서 나아가 에러명과 출력할 값까지 편집 가능.
![[Pasted image 20240731223851.png|400]]
![[Pasted image 20240731223910.png|500]]

#### 하위 코루틴
yield from 하위코루틴명() 을 통해 하위 코루틴 이용 가능.
![[Pasted image 20240731224023.png|500]]
밖에서 send()를 하면 yield from을 거쳐 하위 코루틴까지 <span style="background:#fff88f">직접 전달 됨</span>.
밖에서 for을 통해 하위 코루틴에 값을 직접 주며 반복을 계속 시킴.
for문이 끝나고 none을 보내면 그때 return이 raise StopeIteration를 일으켜 그냥 코루틴에 값을 반환함.

추가 문제 애매한 함수 정의
![[Pasted image 20240731163001.png|400]]


## 정규표현식
문자열에서 패턴을 가져오는 것
![[Pasted image 20240731165153.png]]

참고 사이트:
[08-2 정규 표현식 시작하기 - 점프 투 파이썬](https://wikidocs.net/4308)

> [!파이썬 팁:]
> r' 문자열 \\n '
>  여기 앞에 r(raw string이 붙으면) 뒤에는 특수기호 상관없이 무조건 문자열로 읽음.
>  정규표현식에서 자주 쓰임

#### import re
로 사용 가능
### re.match()
re.match( 패턴, 문자열)로 검사 가능
근데 아쉽게도 일반 match로는 처음 부터 나타나는 패턴만 판별 가능.
뒤에 까지 보려면 앞에서 무시할 문자열을 작성해야 됨.

검사 문자열 안에 패턴이 없다면 아무것도 반환 안됨.

```python
변수 = re.match( _ , _ )
if 변수:
	print(f"{변수}")
```
위에 처럼 match()를 어디에 할당했을 때:
이거를 if 문 앞에 두면 T/F 출력이 되고
출력하면 내용물이 나옴.(예시: <re.Match object; span=(10, 16), match='sample'>)

### re.search()
![[Pasted image 20240731165611.png]]
비슷한 방식으로 서치가 있음.
맨앞뒤 상관 없이 문자열을 찾음. 가장 앞에 있는 것 만
![[Pasted image 20240731165800.png|300]]
span으로 반환 되는 것은 인덱스임.(인덱스가 6이라는)

하지만 문자열에 ^나 $를 붙이면
맨앞이나 맨뒤를 한번만 봄. 즉, 위의 같은 경우 o는 못 찾음

### 다시 re.match()
###### OR
찾는 문자열 안에 or( | )를 집어 넣으면 둘중 하나만 있어도 반환 됨.
###### \*와 +
뒤에 \*이 붙으면 그 바로 앞에 있는 것이 0개 이상일때 인식, 이게 뭔소리냐면 그냥 있든 없든 상관 노. 일단 인식을 시킴. (**단, 다른거 들오면 안됨**)
![[Pasted image 20240731173923.png|400]]
![[Pasted image 20240731174409.png|370]]
위에는 인식이 되지만, 아래는 안됨.
![[Pasted image 20240731174451.png|370]]

'+'는 하나 이상이 있어야 발동.
물론 둘다 맨앞 기준 부터.
![[Pasted image 20240731174156.png|320]]

###### ?와 .
![[Pasted image 20240731174644.png|600]]
abc?d인 경우 abcd와 abd는 되지만 abzd는 안됨. \*랑 비슷 한 듯
![[Pasted image 20240731174952.png|370]]
. 은 그 자리에 아무 문자가 들어와도 ㄱㅊ. 한자리만 딱 들어오면 됨.
하지만 안들어오면 발동 노.

###### 문자{개수}
이런식으로 맨앞 기준으로 개수만큼 연속 돼서 맞는 것을  찾을 수 있음.
\[0-9]{3} 이런식으로 이 번호 안에 몇개가 연속으로 들어올지도 찾기 가능.
![[Pasted image 20240731175541.png|500]]
\[0-9]{3,7} 이렇게 개수의 범위도 지정 가능.

###### 범위
\[a-zA-Z0-9] 참고로 이 것의 뜻은 소문자/대문자 a 부터 z와 숫자 다 되는 것이다.
한국어로는 **가-힣** 하면 됨.

###### 제외 \[^문자]
\[] 안에 ^를 적어놓으면 그 후 문자열 제외를 가져옴(물론 처음 것만). 
![[Pasted image 20240731191858.png|350]]
하지만 이렇게 뒤에 개수 적으면 여러개 가능

==주의! search()에서 ^를 앞에 써서 맨 앞 부터 검사하는거랑 다름! search 맨 앞 검사는 ^\[]이고 제외는 \[^]임!== 
반대로 뒤에 부터 검사는 \[ ]\*$로 가능. 

###### 문자 판단 단축 명령
![[Pasted image 20240731193208.png|600]]
아래 보고 외우지 말고 위에 설명 보고 외우셈
###### 공백 처리 '  '
\\s 주로 이용.
그냥 공백 ' ' 넣어도 되긴함.
![[Pasted image 20240801072929.png|500]]

##### Group
그룹별로 나워서 받는 것은 쉽다
그냥 그룹별로 ( )로 묶으면 됨.
![[Pasted image 20240801081026.png|450]]
( )를 하면 그 안의 내용물이 맞으면 알아서 들어감.
근데 만약 둘 중에 하나가 없으면 그냥 에러남.
==참고로 ( )를 할 때 안에 개수를 굳이 안적어도 적용 되는거 전부 가져옴.==

부르는 방식이 살짝 특이힘.
m.group( )를 통해 하나씩 또는 여러개 부를 수 있는데.
아무것도 안적거나 0을 적어 넣으면 전체 출력이고.
처음 것이 1로 시작함.
앞에 전체가 있으니 일반적인 인덱스랑 다르게 생각할 것.

m.groups()를 하면 나눠서 튜플로 반환
그냥 group()는 하나의 문자열로 전체를 돌려줌.

###### 그룹에 이름 지정
( )로 그룹 만들 때 안에 이름을 지정 할 수 있음.
(?P<그룹명>패턴내용)
![[Pasted image 20240801083817.png|500]]
이제 숫자가 아니라 m.group('그룹명')으로 불러오기 가능.

### <span style="background:#fff88f">re.findall( , )</span>
이걸 쓰면 그냥 조건 맞는거 다 가져와서 리스트로 반환.
![[Pasted image 20240801084443.png]]

#### 정규식 패턴 내용 정리
![[Pasted image 20240801084043.png]]

![[Pasted image 20240801084108.png|500]]

## 문자열 교체, re.sub()
sub을 이용하여 교체 가능
re.sub('패턴', '새로 넣을 내용', '검사 문자열', '횟수')
횟수는 안적으면 해당 되는거 다 바꿈.
![[Pasted image 20240801084628.png]]

##### ==re.sub()에서 그룹 다시 사용==
위에서 했던 그룹에서 나아가
지정된 그룹을 재사용 할 수 있음.
숫자면 \\\\1 처럼 사용 가능.
![[Pasted image 20240801085234.png|500]]
아래줄 구조 설명
![[Pasted image 20240801085355.png|300]]
![[Pasted image 20240801085247.png|400]]
교체임, 재창조 아님.

\\\\g<그룹명>으로 키로도 다시 부를 수 있음.
![[Pasted image 20240801085512.png|600]]