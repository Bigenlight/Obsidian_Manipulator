---
title: 인공지능기초와 활용
date: 2024-10-05
tags:
  - "#개인공부"
  - 수업
related notes: "[[개인 공부]]"
Review: 
비고:
---
# 1주차
**서울과학기술대학교 K-MOOC  
인공지능 기초와 활용  
1주차  
인공지능의 역사와 흐름**

**INDEX**  
인공지능의 역사와 흐름  
01 인공지능 개요  
02 인공지능의 도전과 발전  
03 AI로 할 수 있는 것들(1)  
04 생활 속의 다양한 응용  
05 인공지능과 교육  
06 인공지능의 중요성  
07 AI로 할 수 있는 것들(2)


**01  
인공지능의 역사와 흐름**

**1. 인공지능 개요**

**학습개요**

- 인공지능이 무엇이고 장점과 단점에 대해 알아본다.

4p
**학습목표**

- 인공지능의 정의를 이해한다.
- 인공지능의 장점과 단점을 이해한다.

**인공지능 (Artificial Intelligence; AI)**

- 컴퓨터를 사용하여 **인간의 지능을 모사**하는 기술
- 인간의 지능으로 수행할 수 있는 다양한 인식, 사고, 학습, 활동 등을 **컴퓨터가 할 수 있도록 하는 방법**을 연구하는 분야

---

**기계지능 (Machine Intelligence)**

- **컴퓨터나 기계장치들을 통해** 지능을 구현할 수 있는 방법을 연구하는 분야

---

**인공지능이란 무엇인가? (Cont'd)**

---

**인공지능에 대한 여러 말들**

- **인공지능의 시대는 이미 시작됐다.** 이런 흐름은 이제 바꿀 수도 없고 막을 수도 없다.
- 인공지능은 똑똑한 **기계가 스스로 작동하도록 하는 고차원의 기술**이다.
- 인류는 이제 인공지능을 이용하여 **두뇌의 한계를 넘어**서려고 한다.
- 주어진 일을 **비판 없이 열심히 하면 되는 일**은 이제부터 인공지능이 대체할 것이다.
- **인간은 어떤 일을 할지 최종적으로 결정한 후 인공지능에 맡기는 사회**가 올 것이다.
---
**인공지능이란 무엇인가? (Cont'd)**

**인공지능에 대한 여러 말들**

- 인간은 올바르게 선택하고, 인공지능은 효율적으로 작동하는 것이 중요하다.
- 인공지능은 가까운 미래에 사람의 말을 이해하고 상황에 적절한 문장을 만들 것이다. (이미 달성)
- 인공지능을 잘 이용하는 사람이 다가오는 4차 산업혁명의 경쟁에서 앞서갈 수 있다.
- 인간은 산업혁명에서 근육의 한계를 극복했고, 인공지능으로 두뇌의 한계를 뛰어넘는다.

---

**인공지능이란 무엇인가? (Cont'd)**

**날로 발전하는 인공지능**

- 인공지능 태동, 1950년 중반
    
    - 간단한 게임, 문자 인식 등의 제한적 문제 해결
- **현재의 인공지능**
    
    - 지식 처리 면에서 고도화 됨, 음성, 영상의 인식과 처리가 가능
    - 소프트웨어에만 머물지 않고, 지능적 로봇으로 구현되고 있음

**예시**

- 악기 연주 로봇 [링크](https://www.youtube.com/watch?v=bAdqazixuRY)
- 감성 로봇 페퍼
- 수험 로봇, 도로보콘

이미지 출처: 아시아경제, https://news.v.daum.net/v/20160311085026296

---

**인공지능이란 무엇인가? (Cont'd)**

**날로 발전하는 인공지능**

- 인공지능을 접하고 익혀야 하는 이유는?
    - 급속히 변해가는 시대의 핵심 기술 발전의 배경을 이해할 필요가 있음
    - 문제 해결을 위한 효율적인 방법 구상에 큰 도움이 됨
    - 인간의 판단 능력과 인공지능 기술의 융합으로 시너지 효과가 기대됨
    - 급속히 변화하는 미래 사회 적응에 큰 도움이 됨

---

**인공지능이란 무엇인가? (Cont'd)**

**컴퓨터를 이용한 인공지능**

- 인간과 컴퓨터의 비교

| 기능     | 인간              | 컴퓨터    |
| ------ | --------------- | ------ |
| 입력기능   | 감각기관            | 입력장치   |
| 기억장치   | 두뇌              | 주기억장치  |
| 연산기능   | 두뇌              | 연산장치   |
| 제어기능   | 두뇌              | 제어장치   |
| 출력기능   | 반응 기관 (입, 손, 발) | 출력장치   |
| 보조기억기능 | 노트 등            | 보조기억장치 |

---
**인공지능이란 무엇인가? (Cont'd)**

**인공지능의 장점**

- 생활의 상당 부분 인간의 역할을 대신할 수 있음  
    예) 자율주행, 스마트 홈, …
- 인간의 판단과 결정에 도움을 줄 수 있음  
    예) 추천, 예측 시스템, …
- 인간의 실수와 위험을 줄일 수 있음  
    예) 우주탐사, 응급, 방사능 진단, …

---

**인공지능이란 무엇인가? (Cont'd)**

**인공지능의 단점**

- 사람의 일자리를 빼앗음 (대체함)
- 인공지능을 활용하는데 있어 윤리적 문제가 발생함
- 인공지능에 종속되어 조종 받을 수 있음

---

**인공지능이란 무엇인가? (Cont'd)**

**인공지능의 장·단점**

|**장점**|**단점**|
|---|---|
|인간의 역할을 대신하여 편리함을 제공함|인간의 일자리가 위험 받을 수 있음|
|로봇이 24시간 일함으로써 생산성 향상|인공지능에 의존적이며 종속적이 될 위험이 있음|
|빠르고 올바른 판단에 도움을 줌|인공지능에 의해 감시 받거나 조종 받을 위험이 있음|
|인간의 실수와 위험을 줄임|연구와 개발이 어려움|
|개인 비서 역할이 가능함|인간관계가 줄어들 가능성이 있음|

---
## 01 인공지능의 역사와 흐름

**2. 인공지능의 도전과 발전**

**학습개요**

- 인공지능의 발전과 역사를 이해한다.

**학습목표**

- 인공지능의 종류를 이해한다.
- 인공지능의 발전 과정을 이해한다.

**인공지능의 도전과 한계**

**④ 인공지능 시스템의 구성**

- **Hardware**: Computing Power
- **Software**: Model, Algorithm, Library
- **Data**: Image, Text, Voice, Video ...
---
### 01 인공지능의 역사와 흐름

**2. 인공지능의 도전과 발전**

**(이미지)** 인공지능이란? 지능적인 에이전트를 만들려는 컴퓨터 과학의 한 분야이다. - John McCarthy

**학습개요**

- 인공지능의 발전과 역사를 이해한다.

**학습목표**

- 인공지능의 종류를 이해한다.
- 인공지능의 발전 과정을 이해한다.

**인공지능의 도전과 한계**

**인공지능이란 용어 사용의 한계**

- 인공지능이란 말은 여러 분야에서 우리에게 큰 기대를 주고 있음
- 그러나 정말 인간에 견줄 만큼의 지능이라 할 수 있는가?
![[Pasted image 20241006185931.png]]
**(이미지)** Marvin Minsky (1927-2016) - 인공지능은 인간과 같이 사고하는 기계를 개발할 것

**인공지능에 대한 기대와 끝없는 노력**

![[Pasted image 20241006185941.png]]

| **시대**        | **기술**  | **특징**                          |
| ------------- | ------- | ------------------------------- |
| 1950년대~1960년대 | 초기 인공지능 | - 탐색 기반 문제 해결 - 논리 및 추론         |
| 1970년대        | 전문가 시스템 | - 지식 기반 시스템                     |
| 1980년대        | 머신러닝    | - 데이터 기반 학습                     |
| 1990년대        | 딥러닝     | - 인공 신경망                        |
| 2000년대~현재     | 딥러닝의 발전 | - 빅데이터, GPU 발전 - 이미지 인식, 자연어 처리 |


**(이미지)** 인공지능의 역사 (연대표) - 튜링 테스트 (1950) → 다트머스 회의 (1956) → 퍼셉트론 (1957) → 전문가 시스템 (1970년대) → 머신러닝 (1980년대) → 딥러닝 (1990년대) → 알파고 (2016)

**인공지능 시스템의 구성**

- **Hardware**: Computing Power
- **Software**: Model, Algorithm, Library
- **Data**: Image, Text, Voice, Video ...
---
**인공지능의 도전과 한계 (Cont'd)**

**인공지능의 한계**

- 인공지능이 추구하는 것은 결국 지능을 컴퓨터나 로봇과 같이 인공물로 실현하는 것
- 여기에 몇 가지 도전 과제가 있음

---

**인공지능의 한계 (Cont'd)**

- **학습의 문제**
    
    - 실세계에 무한히 가까운 문제를 **학습하기 어려움**
    - 가능하더라도 학습에 **많은 시간이 걸릴 수 있음**
- **실세계에 적용하는 문제**
    
    - 여러 분야에 여전히 학습에 사용할 데이터가 매우 부족함
- **정신세계에 대한 표현의 어려운 문제**
    
    - 인간의 지능이나 행위를 정의하기 어려운 문제들이 많음
    - 인간의 정신세계로 표현되는 관련 연구가 선행되어야 함

---

**인공지능의 도전과 한계 (Cont'd)**

**인공지능은 신에 대한 도전인가?**

- **학습의 문제**
    - 인공지능 연구에 대해 신에 대한 도전으로 받아들이는 경우가 있음
    - 현재까지의 인공지능 수준에서는 걱정할 필요가 없는 문제임
    - 그러나 Intelligence explosion, Singularity 등을 마주하게 된다면 심각한 고민이 될 수도 있음
    - 생물학 탐구를 통해 인체와 유전자, 뇌에 대해 규명해 가는 것처럼 인공지능의 연구와 구현도 같은 맥락이라 볼 수 있음

---

**인공지능의 큰 흐름**

**기호주의 인공지능과 연결주의 인공지능**

- 기호주의 인공지능 (Symbolism AI)
    - Symbol, Rule-based system
- 연결주의 인공지능 (Connectionism AI)
    - Neural network
- 통계적 인공지능 (Statistics AI)
    - Data-driven model

**표: 인공지능의 주요 흐름**

- 기호주의 (Symbolism): Symbol, Rule-based system
- 연결주의 (Connectionism): Neural network
- 통계적 (Statistics): Data-driven methods

---

**인공지능의 큰 흐름 (Cont'd)**

**인공지능의 분류**

- Artificial Intelligence
- Machine Learning
- Deep Learning

(그래프) 인공지능의 계층 구조:

- **Artificial Intelligence** > **Machine Learning** > **Deep Learning**
---
**인공지능의 시작과 발전**

**인공지능은 최근의 기술인가?**

- 2010년 이후 우리에게 큰 영향을 미치고 있음
- 그런데 1950년 중반부터 꾸준히 발전해온 연구 분야이기도 함
- 다른 학문에 비해서는 역사가 짧지만, 컴퓨터과학 분야에서는 매우 오래 연구되어 온 분야임

**그래프: 학문별 연구 년수**

- 의학 (NEJM): 약 250년
- 철학 (MIND): 약 150년
- 인공지능 (AI): 약 70년

---

**인공지능의 시작과 발전 (Cont'd)**

**인공지능의 역사 요약**

|연도|구분|주요 내용|기타|
|---|---|---|---|
|1943년 ~ 1956년|준비기|맥컬록과 피츠, 알렌 튜링, 퍼셉트론|명제논리의 개념, 튜링 테스트, 최초의 체스 프로그램|
|1956년 ~ 1974년|태동기|다트머스 회의, 로직 이론가, 엘리자, 퍼셉트론, 린즈의 패배론|인공지능 이론 연구활성화, LISP 언어 개발, 엘리자, 퍼셉트론 개발|
|1974년 ~ 1980년|암흑기|미국과 영국 연구비 감소|신경망 학습 실패로 연구비가 감소|
|1980년 ~ 1987년|재도약기|전문가 시스템, 뉴런의 재발견|‘XCON’ 전문가 시스템, 토대 마련|
|1987년 ~ 1993년|제2 암흑기|상업용 실패, 미군, DARPA|비용 과다 문제, 연구비 감소로 암흑기|
|1993년 ~ 2011년|르네상스기|IBM Deep Blue, IBM Watson|챗봇, 구글의 자율주행차|
|2011년 ~ 현재|부흥기|힌튼, 딥러닝, 알파고|딥러닝, 딥강화학습, 세계 바둑 챔피언|

---

**인간 두뇌 영역에 도전하는 인공지능**

**다양한 분야로의 도전**

- 최근의 인공지능 기술은 다양한 분야에 도전하고 있음
- 예술이나 문학에서 만큼은 인간을 따라가지 못한다고 여겼지만 지금은 그렇지 않음
- 기사, 시와 소설의 작성, 음악을 작곡하고 그림을 그림
- 인공지능이 제작한 저작물의 권리와 책임은 누구에게 있는가?

---

**인간 두뇌 영역에 도전하는 인공지능 (Cont'd)**

**문서 작성**

- 로봇 저널리즘, 포브스(Forbes)의 주식 시장 기사, 오토메이티드 인사이츠의 스포츠 기사 등…

**표: 문서 작성에 사용되는 프로그램 예시**

|언론사|프로그램 이름|활용분야|
|---|---|---|
|포브스|퀼(Quill)|주식 시장과 스포츠 경기의 결과를 바탕으로 기사 작성|
|AP통신|워드스미스|기업 실적 기사 작성|
|LA타임즈|퀘이크봇|지진 관련 정보를 수집해서 기사 작성|
|가디언|Unknown|주간지 기사 편집|
|로이터|트레이서|소셜미디어 이용한 속보 기사 작성|
|아시아타임즈|오토리|고교 야구 경기평가 기사 작성|

**내용 출처:** 가디언, [https://www.theguardian.com/commentisfree/2020/sep/08/robot-wrote-this-article-gpt-3](https://www.theguardian.com/commentisfree/2020/sep/08/robot-wrote-this-article-gpt-3)

---

**인간 두뇌 영역에 도전하는 인공지능 (Cont'd)**

**시를 쓸 수 있는가?**

(이미지: 창의 AI × BOOKATHON 대회)

- 인공지능과 함께 시 쓰기
---
**인간 두뇌 영역에 도전하는 인공지능 (Cont'd)**

**그림은?**

(이미지: 두 개의 그림, 왼쪽은 별이 빛나는 밤, 오른쪽은 인물 배경의 그림 변형)  
이미지 출처: OSTAGRAM, https://www.ostagram.me/about?locale=en

---

**마무리 및 시사점**

- 인공지능은 끝없이 도전하고 있다.
- 인공지능은 기호주의, 연결주의, 통계적 인공지능으로 구분된다.
- 최근 인공지능 사람처럼 글 쓰기, 그림 그리기를 하고 있다
---
**01 인공지능의 역사와 흐름**

**3. AI로 할 수 있는 것들(1)**

**학습개요**

- 인공지능으로 할 수 있는 예시를 보여주고 그 의미를 이해한다.

**학습목표**

- 인공지능 응용을 통해 인공지능이 할 수 있는 것을 이해한다.
- 인공지능 응용을 통해 인공지능이 잘하는 것을 이해한다.

---

**실습 1 - 손으로 쓴 숫자는 몇일까?**

- 사람이 마우스로 쓴 아라비아 숫자를 컴퓨터가 맞히기  
    링크: [https://tensorflow-mnist.herokuapp.com](https://tensorflow-mnist.herokuapp.com)

(이미지: MNIST 손으로 쓴 숫자 '4'와 결과 화면)

---

**실습 2 - 빠르고 정확히 그림 그리기**

- 제시한 단어를 빠르게(20초 안에) 그리면 컴퓨터가 맞히기  
    링크: [https://quickdraw.withgoogle.com/?locale=ko](https://quickdraw.withgoogle.com/?locale=ko)

(이미지: '잘 그리셨어요!'라는 메시지와 그린 그림들)

---

**실습 3 - 성대 모사**

- 컴퓨터가 특정 사람의 목소리를 학습하여 그 성대 모사를 하여 문장을 읽어 주기  
    링크: [https://carpedm20.github.io/tacotron/](https://carpedm20.github.io/tacotron/)

(이미지: Multi-Speaker Tacotron in TensorFlow 샘플 페이지)

---
**실습 4 - 다음에 쓸 단어는?**

- 기존의 문장들을 학습한 컴퓨터가 나열된 단어들 다음에 올 단어를 추천하기  
    링크: [https://demo.allennlp.org/next-token-lm](https://demo.allennlp.org/next-token-lm)

(이미지: Model Output 페이지)

---

**실습 5 - Auto Coloring!**

- 여러 스타일의 그림을 학습한 컴퓨터가 사용자의 색칠을 자동으로 도와주기  
    링크: [https://paintschainer.preferred.tech/index_en.html](https://paintschainer.preferred.tech/index_en.html)

(이미지: PaintsChainer 자동 색칠 화면)

---

**마무리 및 시사점**

- 인공지능은 우리가 쓰고, 보고, 듣는 것을 이해할 수 있다.
- 인공지능은 잘하는 것을 잘한다.
---
### 01 인공지능의 역사와 흐름

**4. 생활 속의 다양한 응용**

**(이미지)** 인공지능이란? 지능적인 에이전트를 만들려는 컴퓨터 과학의 한 분야이다. - John McCarthy

**학습개요**

- 생활 속의 다양한 인공지능 활용 사례를 살펴본다.
- 인공지능의 긍정적 측면과 부정적 측면을 비교 분석한다.
- 인공지능과 다른 산업 분야의 융합을 이해한다.

**학습목표**

- 인공지능이 우리 주변에서 사용되는 분야를 이해한다.
- 인공지능이 다른 산업과 어떻게 결합하는가를 이해한다.

**인공지능의 생활 속의 다양한 응용**

- 인공지능의 광고(관심 주제)에서의 활용
    - 인터넷으로 신문 기사를 읽는 도중에 중간 광고가 나타남
    - 여러 번 검색하며 관심을 가졌던 주제와 관련된 광고, 그 외 도서 검색 경험을 바탕으로 한 추천 광고

**인공지능의 생활 속의 다양한 응용 (Cont'd)**

- 인공지능의 광고(맞춤형)에서의 활용 (Cont'd)
    - 유튜브(YouTube)에서 인공지능이 동영상 추천
    - 인공지능이 사용자가 자주 찾는 프로그램 경향 분석
    - 유튜브를 켜면 자주 보는 환경 관련 콘텐츠 추천

**인공지능의 생활 속의 다양한 응용 (Cont'd)**

- 인공지능의 사물(얼굴) 인식
    - 인공지능 기술로 얼굴과 사물 인식에서 실용화 단계 도달
    - 중국의 베이징대에서 인공지능 신입생 등록 시스템 도입
        - 얼굴 인식기와 신분증 인증 시스템으로 간편하게 등록
    - 중국의 대형마트 등에서는 얼굴 인식으로 결제

**인공지능의 생활 속의 다양한 응용 (Cont'd)**

- 인공지능 로봇 심판의 출현
    - 어떤 스포츠 경기에서나 심판의 공정성 시비가 있음
    - 미국에서 인공지능 '로봇 심판'이 스트라이크나 볼 판정
        - 측면 시비가 사라져 불만이 줄어드는 장점
    - 인공지능 로봇이 전적으로 담당하면 인간 심판은?
---
### 인공지능의 생활 속의 다양한 응용(Cont'd)

- **인공지능 가사도우미**
    - KIST에서 개발한 휴머노이드 가사도우미 로봇 '마루 Z'
    - 자율보행 능력을 갖추고 있음
    - 물건을 정확하게 집어 이동시킬 수도 있음

### 인공지능의 생활 속의 다양한 응용(Cont'd)

- **인공지능을 이용한 인공 벌 연구 개발**
    - 인공 벌(Artificial Bee)을 신경망 기술로 작은 로봇으로 구현
    - 하버드대학 연구팀은 2013년 처음으로 '로봇 벌' 개발
    - 로봇 벌은 2개의 날개로 초당 120번 펄럭일 수 있음
    - 로봇 벌은 원격 제어 가능, 4개의 날개로 개량
    - 비 플러스(Bee+)는 비행, 착륙과 물속을 헤엄칠 수도 있음
    - 꽃가루 수정 활동, 수색 작업, 탐사 활동 등에 활용

### 인공지능의 생활 속의 다양한 응용(Cont'd)

- **인공지능 서비스 로봇**
    - 인공지능 로봇은 서비스업에도 활용되기 시작
    - 독일의 바에서 로봇이 맥주를 잔에 채워 종업원에게 전달
    - 바텐더 로봇(Robot bartender)은 정교하게 설계되어 있음
    - 바텐더 로봇은 커피도 섬세하게 따를 수 있음

### 인공지능의 생활 속의 다양한 응용(Cont'd)

- **우리나라의 로봇 카페**
    - 서울 성수동에 로봇과 인간이 공존하는 '카페 봇(cafe.bot)'
    - '디저트 봇'은 케이크 위에 그림과 글을 새겨 넣음
    - '바리스타 봇'은 5분 동안 3잔의 커피 추출 가능
    - 성대 도서관 '비트 커피'

### 인공지능의 생활 속의 다양한 응용(Cont'd)

- **인공지능 스피커**
    - 인공지능 스피커는 인공지능을 이용한 스피커 장치
    - 음성인식을 통해 집안의 기기를 음성으로 제어
    - 음성으로 통신망에 연결된 가전기기를 제어할 수 있음
    - 시장이 확대 중이며 디스플레이 탑재가 추세
---
### 인문학과 인공지능

- 인공지능 열풍은 인문학에도 영향을 미치고 있음
- 인문학은 인간의 사상과 문화를 연구하고 탐구하는 학문 영역
    - 문학, 역사학, 언어학, 철학, 종교학, 신학, 고고학, 예술학 등
- 미국 스탠포드 대학에서 인간중심 인공지능연구소(HAI) 설립
    - HAI에서는 인공지능 개발자와 인문학자와 협업하여 연구 중

### 인공지능의 타 학문 분야에의 응용(Cont'd)

- **법률과 인공지능**
    - 법률은 용어부터 매우 어렵고 절차도 매우 까다로운 편
    - 리갈테크(LegalTech)는 법(Legal)과 기술(Technology)의 합성어
    - 인공지능이 법률전문가인 변호사를 대체할 가능성은?
        - 인공지능 변호사가 법조인의 업무를 보조하는 역할은 합법적
    - 미국의 인공지능 변호사는 판례 정보 제공과 자연어 대화 가능

### 인공지능의 타 학문 분야에의 응용(Cont'd)

- **의학과 인공지능**
    - 최근 인공지능의 의학 분야에서의 활용도 늘어나고 있음
    - IBM의 인공지능 컴퓨터 '왓슨'은 의료 분야에서도 큰 성과
        - 왓슨은 암 발견과 최적의 암 환자 치료를 수행

### 인공지능의 타 학문 분야에의 응용(Cont'd)

- **로봇공학과 인공지능**
    - 인간 모습으로 인간과 교감 가능한 로봇 휴머노이드(Humanoid)
        - 휴머노이드 '소피아(Sophia)'는 사람 피부와 인공지능 알고리즘으로 60여 개 감정 표현과 사람과 대화 가능
        - 배우 윌 스미스(Will Smith)와 농담을 주고받을 정도

### 인공지능의 타 학문 분야에의 응용(Cont'd)

- **농업과 인공지능**
    - 최근 들어 인공지능의 농업 분야에서의 활용이 늘어남
        - 농업을 로봇과 스마트 농업기술
        - 인공지능 로봇은 물이나 영양제를 뿌리는 등에도 활용됨
        - 포도 등 과일을 수확하는 일에도 활용되고 있음
    - 축산에 있어서 사료를 공급하는 역할도 가능

### 마무리 및 시사점

- 우리 주변에서 이미 인공지능은 많이 사용되고 있다.
- 인공지능은 의료, 법률, 농업과 협력하고 있다.
- 통찰력을 바탕으로 인문학도들은 인공지능을 빠르게 이해 가능

**이미지에서 확인되는 내용:**

- **유명인**: 배우 윌 스미스
- **객체**: 휴머노이드 로봇 소피아, IBM 인공지능 컴퓨터 왓슨
---
**01 인공지능의 역사와 흐름**

**5. 인공지능과 교육**

---

**학습개요**

- 인공지능 시대에 국가들이 준비하는 인공지능 교육을 알아본다.

**학습목표**

- 선진국에서 진행하는 인공지능 교육을 이해한다.
- 왜 인공지능 교육에 많은 국가들이 정성을 들이는지를 이해한다.

---

**인공지능 기술 경쟁과 인공지능 교육**

**인공지능 기술의 치열한 경쟁**

- 미국, 중국, 일본, 프랑스, 독일 등 국가 경쟁이 치열
- 현재 선진국 정상들이 인공지능 정책을 진두지휘하고 있음
- 미국의 트럼프 대통령은 인공지능 관련 행정명령에 서명
    - 각국 차원의 인공지능 전략 수립과 국외 유출 방지 조치
- **중국의 시진핑**은 **차세대 인공지능 발전 계획** 추진
    - 2025년에는 미국의 인공지능 수준을 뛰어넘겠다는 목표
    - 엄청난 금액의 인공지능 연구개발비와 보조금 투입 중

(이미지: 미국과 중국 국기)

---

**인공지능 기술 경쟁과 인공지능 교육 (Cont'd)**

**인공지능 기술의 치열한 경쟁 (Cont'd)**

- 프랑스, 독일 등도 인공지능 개발에 **국가적 차원에서 대응**
    - 프랑스의 마크롱 대통령은 파리를 인공지능의 중심지로 목표
    - 파리엔 삼성이 인공지능 연구소 유지와 **Station F** 오픈
    - 독일은 제조업에 인공지능을 접목한 **인더스트리 4.0**

---

**인공지능 기술 경쟁과 인공지능 교육 (Cont'd)**

**일본의 인공지능 교육**

- 최근 일본 정부가 인공지능 인재 육성 전략 발표
    - 초등 과정부터 평생교육까지 인공지능 인재 육성
    - 2020년부터 초등학생에게 인공지능 교육 의무화
- 대학과 신입생 **60만 명 전원 인공지능 기초 교육** 실시

**일본 정부의 인공지능 인재 육성 전략**

- 전국의 고등학생과 대학생들에게 인공지능 기초 교육 실시
- 연간 25만 명의 인공지능 전문 인력 양성
- 대학에서 사회인 인공지능 전문 과정 설치

---

**인공지능 기술 경쟁과 인공지능 교육 (Cont'd)**

**중국의 인공지능 교육**

- 2025년까지 인공지능이 혁신 산업 발전의 원동력 목표
- 2030년에는 중국이 세계 최고의 인공지능 국가 목표
- 교육 열풍으로 2018년 고교에서 인공지능 수업 진행
    - 다양한 인공지능 교육 프로그램 개발
    - '인공지능 기초', '기계 학습' 등 수업
    - '데이터 과학과 빅데이터 기술' 출판

(이미지: 인공지능 교육 관련 도서)

---
**인공지능 기술 경쟁과 인공지능 교육 (Cont'd)**

**미국 MIT의 인공지능대학 설립**

- 10억 달러(1조 2천억 원)를 들여 '인공지능대학' 설립 발표  
    (The MIT Stephen A. Schwarzman College of Computing)
- 2020년 가을 개강, 새 건물로 자리 옮김
- 인공지능 시대에 대응할 인재양성 계획을 실현에 옮기는 것
- 필요한 자금을 모금 형식으로 충당, 부유한 마음
- 인공지능, 머신러닝 및 데이터 과학을 다른 분야와 연계 연구

(이미지: MIT Schwarzman College of Computing 로고)

---

**한국의 인공지능 교육**

- 선진국에 비해 우리나라 인공지능 교육은 아직 수준이 낮음
- 2019년 정부 지원의 **인공지능 대학원** 설립 공모사업
- 5개 대학 100여 명의 인공지능 대학원생 선정됨
- 일부 대학에서 인공지능 전체 교양과 교양과목 개설 추진
- 정부 지원의 **SW중심대학**으로 인공지능 교육 활성화 목표

(이미지: 인공지능 관련 회의 장면)

---

**인공지능 기술 경쟁과 인공지능 교육 (Cont'd)**

**한국의 인공지능 교육 (Cont'd)**

- 최근 정부는 인공지능을 국가적 정책으로 확정
- 인공지능 인재 양성, 윤리 등 **AI 국가전략** 마련 중
- 국가적 차원에서 인공지능 기술 육성, '인공지능 정부'
- 2020년도 인공지능과 데이터 분야 예산 총 1조 600억 원
    - 데이터 가치사슬 활성화 (7,200억 원)
    - AI 생태계 조성 (1,900억 원)
    - 데이터/AI/융복합 활용 촉진 (1,400억 원)

---

**마무리 및 시사점**

- 모두의 인공지능 교육은 미래 사회를 위해 필수적인 것이다.
- 인공지능 교육이 국가의 경쟁력이 된다.
---
**01 인공지능의 역사와 흐름**

**6. 인공지능의 중요성**

---

**학습개요**

- 4차 산업혁명으로 인공지능이 얼마나 중요해졌는가를 이해한다.

**학습목표**

- 미래 기술에서 인공지능의 역할을 이해한다.
- 인공지능으로 변화하는 산업을 이해한다.

---

**인공지능의 중요성**

**인공지능 시대**

- 지식산업의 시대에 인공지능의 중요성이 더욱 커지고 있음
- **인공지능 기술을 첨가하면 부가가치가 높아짐**
- 인공지능은 IT 서비스를 통한 지식 창출
- 총 개발비 중 인공지능 비중은 점차 높아지고 있음
    - 자동차 56%, 항공기 60%, 의료 50%가 소프트웨어(인공지능)

---

**인공지능의 중요성 (Cont'd)**

**인공지능**

- BMW의 자율주행차 연구개발비의 약 **90%가 소프트웨어**
- 이 중 인공지능 소프트웨어 개발비가 대부분을 차지
- 테슬라의 전기자동차 개발에 인공지능 기술이 핵심
- 자율주행차를 시험 운행하는 구글도 인공지능 개발

(이미지: 자율주행차 그림)

---

**인공지능의 중요성 (Cont'd)**

**인공지능 (Cont'd)**

- 차세대 전투기인 F35 기능의 92% 이상이 소프트웨어로 구현
- 수십 개의 목표물을 동시에 요격 가능한 핵심 소프트웨어
- 고도의 기술을 필요로 하는 인공지능 기술 포함
- **아바타 (Avatar)**라는 영화의 그래픽 처리에 3만 5천대의 컴퓨터 사용
- 가상현실 구현에 인공지능 기술이 필수적으로 사용됨

(이미지: F35 전투기와 아바타 영화 포스터)

---

**인공지능의 중요성 (Cont'd)**

**인공지능의 중요성**

- 4차 산업혁명 시대에 인공지능이 세상의 변화를 이끌 것이라는 전망
- 인공지능은 지능화 시대에 필수적임

(이미지: AI와 관련된 보고서 표지)

---
**인공지능의 중요성 (Cont'd)**

**인공지능 개발의 중요성**

- 인공지능이 자율주행차 등 대부분 산업에 폭넓게 활용됨
- 인공지능이 제품의 부가가치를 결정하는 핵심 요소
- 세계시장을 선도하는 혁신제품에는 첨단 인공지능이 필수적
- 인공지능은 고용효과가 높고, 선두 기술 추격이 어려움

(이미지: 벤츠 CEO Dieter Zetsche와 인용구)

---

**인공지능의 중요성 (Cont'd)**

**인공지능 시대의 융합**

- 인공지능과 여러 다양한 분야의 융합이 가능
- 몇 가지 전공별로 살펴본 소프트웨어 융합의 예
    - 생물학 + 소프트웨어
    - 바이오인포매틱스란 생명정보과학 분야

(이미지: DNA 이미지)

---

**인공지능의 중요성 (Cont'd)**

**인공지능 시대의 융합 (Cont'd)**

- 음악 + 인공지능 → 컴퓨터 악보
- 음악에 소프트웨어를 활용하여 음악 연주
- 화성법을 적용하여 컴퓨터 악보 제작

(이미지: 음악 스튜디오)

---

**인공지능의 중요성 (Cont'd)**

**인공지능 시대의 융합 (Cont'd)**

- 건축학 + 인공지능 → 구조설계 인공지능
- 건축학에서 CAD(Computer-Aided Design) 소프트웨어에 활용
- 설계하려는 건축물의 구조, 강도 등을 시뮬레이션하며 테스트

(이미지: 건축 설계 시뮬레이션 화면)

---

**인공지능의 중요성 (Cont'd)**

**인공지능 시대의 융합 (Cont'd)**

- 화학 + 인공지능 → 가상현실 시뮬레이션
- 소프트웨어를 화학물질에 적용하여 분자 구성을 입체적으로 봄

(이미지: 화학 시뮬레이션 화면)

---

**인공지능 도우미**

**인공지능 도우미들 (Assistants)**

- 구글의 '구글 어시스턴트'
- 마이크로소프트의 '코타나'
- 애플의 '시리'
- 페이스북의 '챗봇'
- 아마존의 '알렉사'
- 삼성전자의 '빅스비'
---
**인공지능 도우미 (Cont'd)**

**인공지능 도우미들 (Assistants) (Cont'd)**

- **삼성전자의 '빅스비'**
    - 2017년 공개한 삼성전자의 인공지능 가상 비서 소프트웨어
    - 갤럭시S8 이후 버전에 탑재됨
    - 음성인식을 통한 대화 가능
    - 카메라로 이미지, 텍스트, QR 코드 등 인식 가능

(이미지: 빅스비와 관련된 사진)

---

**인공지능 도우미 (Cont'd)**

**인공지능 공개 동향**

- 마이크로소프트의 코타나 오픈소스
- 구글의 텐서플로(TensorFlow) 오픈소스
- 페이스북의 빅서(Big Sur) 공개
- 바이두의 WARP-CTC 공개

(이미지: GPU 서버와 관련된 이미지)

---

**마무리 및 시사점**

- 주요 산업에서 인공지능의 비중은 점점 늘고 있다.
- 인공지능의 적용으로 산업에 변화가 오고 있다.
---
**01 인공지능의 역사와 흐름**

**7. AI로 할 수 있는 것들(2)**

**학습개요**

- 인공지능의 알고리즘을 실습을 통해 이해한다.

**학습목표**

- 인공지능이 동작하는 원리를 실습으로 이해한다.
- 인공지능이 잘할 수 있는 기능을 동작 수준에서 이해한다.

---

**실습 6 - 신경망 실습**

- 텐서플로어로 구현된 신경망의 파라미터를 수정하며 학습해볼 수 있음  
    링크: [http://playground.tensorflow.org](http://playground.tensorflow.org)

(이미지: 신경망 실습 화면)

---

**실습 7 - 가장 가까운 단어는?**

- 단어들의 정보를 신경망으로 학습한 컴퓨터가, 더하고 빼는 연산을 하며 가장 가까운 단어를 추천해주기  
    링크: [http://word2vec.kr/](http://word2vec.kr/)

(이미지: 단어 추천 결과 화면)

---

**실습 8 - K-NN Classification**

- 파라미터에 따른 KNN 알고리즘 분류하는 것을 체험할 수 있음  
    링크: [http://vision.stanford.edu/teaching/cs231n-demos/knn/](http://vision.stanford.edu/teaching/cs231n-demos/knn/)

(이미지: K-NN Classification 실습 화면)

---
**실습 9 - Noise Canceling**

- SEGAN이란 방법을 이용하여 잡음이 있는 음성 데이터에서 잡음을 제거하고 음성을 강화함  
    링크: [http://veu.talp.cat/segan/](http://veu.talp.cat/segan/)

(이미지: SEGAN Speech Enhancement 페이지)

---

**실습 10 - MNIST with GAN**

- GAN을 이용하여 MNIST를 학습하는 것을 보여줌  
    링크: [http://reiinakano.com/gan-playground/](http://reiinakano.com/gan-playground/)

(이미지: GAN Playground 실습 화면)

---

**실습 11 - 흑백을 컬러로!**

- 컬러 이미지들로 학습한 컴퓨터가 흑백으로 된 이미지를 컬러로 만들어 줌  
    링크: [https://demos.algorithmia.com/colorize-photos](https://demos.algorithmia.com/colorize-photos)

(이미지: 흑백 이미지와 컬러 이미지 비교 화면)

---

**마무리 및 시사점**

- 인공지능은 기능별로 잘하는 것이 있다.
- 인공지능의 응용은 단위 기능을 잘 조합한 것이다.
---
# 2주차

**서울과학기술대학교 K-MOOC  
인공지능 기초와 활용**  
**2주차 파이썬 및 필요 모듈 리뷰**

**INDEX**  
01 파이썬의 개요와 개발환경 구축 및 구조와 데이터처리  
02 연산자 및 조건문  
03 반복문 및 함수  
04 리스트와 튜플  
05 사전과 집합, 컬렉션 관리, 표준 모듈  
06 파일 및 클래스  
07 Numpy, Pandas, Matplotlib

---

**02 파이썬 및 필요 모듈 리뷰**  
**1. 파이썬의 개요와 개발환경 구축 및 구조와 데이터처리**

**학습개요**

- 파이썬 언어의 특징과 프로그래밍 구조를 이해한다.

**학습목표**

- 파이썬 언어의 특징을 이해한다.
- 파이썬 언어가 가지고 있는 구조와 데이터 처리 방식을 이해한다.

---

**프로그래밍 언어 (Programming Language)**

- 프로그램을 작성하는 도구의 일종

---

**파이썬 개요와 개발환경 구축**

**프로그래밍 언어**

- **컴파일 언어**
    - 모든 명령을 일괄 번역, 실행
    - 코딩, 컴파일, 실행, 디버깅의 단계
    - 속도 빠른 반면 구조 복잡함
- **인터프리터 언어**
    - 명령어 만날 때마다 즉시 번역하여 실행
    - 속도 느리지만 단순하고 쉬움
![[Pasted image 20241006193158.png|400]]
(이미지: 컴파일러와 인터프리터 구조 설명 그림)

---
**파이썬 개요와 개발환경 구축**

**파이썬(Python) 설치**  
링크: [http://www.python.org](http://www.python.org)

(이미지: 파이썬 설치 화면)

---

**파이썬 개요와 개발환경 구축**

**커맨드 라인 모드: python.exe 실행**

- 프롬프트 뒤에 명령 입력하면 바로 결과 나오고 다시 프롬프트 표시

(이미지: 커맨드 라인에서 Python 실행 화면)

---

**파이썬 개요와 개발환경 구축**

**IDLE 모드: pythonw.exe 실행**

- 텍스트 파일에 입력된 명령 작성하여 한꺼번에 순차적으로 실행

(이미지: IDLE에서 Python 실행 화면)

---

**파이썬 개요와 개발환경 구축**

**코랩(Colab)**  
링크: https://colab.research.google.com

- 구글에서 Colab 검색하여 Google Colab 클릭
- 구글드라이브에 저장하여 웹 브라우저에서 실행
- 데이터 분석에 사용되는 TensorFlow, Keras, Matplotlib, Scikit-learn, Pandas와 같은 패키지가 기본적으로 설치됨

(이미지: Colab 실행 화면)

---

**파이썬 개요와 개발환경 구축**

**파이썬을 사용하는 이유**

- **Open Source**: "Import"
- 파이썬의 각종 라이브러리가 개방됨

(이미지: NumPy 및 TensorFlow import 코드)

---
**파이썬 개요와 개발환경 구축**

**파이썬을 사용하는 이유**

- 각종 공공 개발기업들이 파이썬 사용(협업의 수월성)

(이미지: 파이썬의 특징 설명 그림)

- **Zen of Python** (파이썬 개발자의 마음가짐) 단순함과 가독성
    - 명확함이 암묵적 것보다 낫다.
    - 가독성을 중요하다.
    - 실행하기 어려운 구현이라면 좋은 아이디어가 아니다.
    - 쉽게 설명할 수 있는 구현이라면, 좋은 아이디어일 수 있다.

---

**파이썬 개요와 개발환경 구축**

**수업을 시작하기 앞서...** (코드 예시)

python

코드 복사

`import this`

- The Zen of Python, by Tim Peters

---

**파이썬 구조와 데이터 처리**

**소스의 형식**

- 한 줄에 하나의 명령 작성
    - 세미콜론으로 한 줄에 모두 작성 가능하나, 지양 필요
- 대문자와 소문자의 구분
- 개행과 들여쓰기(Indent) 규칙 준수
    - 들여쓰기는 [Tab] 혹은 4개 공백
- \ # 문자로 주석 달 수 있음
    
    - 명령어가 아닌, 사용자 위한 설명문 (코드 예시)

python

코드 복사

`if age > 19:     print("성인입니다!") for a in range(5):     print(a)`

---

**파이썬 구조와 데이터 처리**

**출력**

- **print** 명령
    - print(출력 내용 [, sep=구분자 [, end=끝 문자]])
    - 출력할 내용 여러 개일 경우 콤마로 나열

(코드 예시)

python

코드 복사

`a = 10 b = 20 c = 30 print(a,b,c, sep=" <= ")`

출력:

코드 복사

`10 <= 20 <= 30`

---

**파이썬 구조와 데이터 처리**

**입력**

- **input** 명령: 사용자에게 질문하여 값 입력받기
    - 변수 = input(질문 내용)
- **int()** 함수: 문자열을 정수로 바꿈

(코드 예시)

python

코드 복사

`year = input("지금이 몇 년이지?") print("내년은: " + str(int(year)+1))`

---
---
**변수 (Variable)**

- 메모리에 이름 붙이고 값을 저장하는 것

---

**명칭 (Identifier)**

- 변수가 다른 것과 구분되도록 이름 붙인 것

---

**파이썬 구조와 데이터 처리**

**변수명**

- **규칙**
    - 키워드나 내장 함수, 표준 모듈명은 사용할 수 없음
    - 모든 명칭은 대소문자를 구분함
    - 알파벳, 밑줄 문자, 숫자 등으로 구성
    - 공백, +, -, 등은 사용 불가
    - 첫 글자로 숫자 사용 불가
    - 한글이나 한자 사용 불가

---

**파이썬 구조와 데이터 처리**

**변수 사용**

- 파이썬 변수는 별도 타입 지정하지 않음
    - 최초 대입하는 값에 의해 결정

(코드 예시)

python

코드 복사

`score = 98 print(score)`

출력: 98

python

코드 복사

`score = 'high' print(score)`

출력: high

- **동적 타입(Dynamic Type)**
    - 실행 중에 변수 타입 바꿀 수 있음
    - 변수는 일단 만들지만 계속 존재하여 값 유지함
        - `del` 명령으로 삭제 가능

---

**파이썬 구조와 데이터 처리**

**정수형**

- 가장 간단한 수치형
- 소수점 이하 값은 표현할 수 없음

(코드 예시)

python

코드 복사

`a = 1234567890 print(a)`

출력: 1234567890

---
**파이썬 구조와 데이터 처리**

**정수형**

- 10진수 아닌 정수는 앞에 접두 붙여 진법 지정, 표시

|진법|접두|사용 가능한 숫자|예|
|---|---|---|---|
|16진법(hex)|0x|0-9, a-f|0x2f|
|8진법(octal)|0o|0-7|0o17|
|2진법(binary)|0b|0, 1|0b1101|

(코드 예시)

python

코드 복사

`a = 0x1a print(a)`

출력: 26

---

**실수형**

- 소수점 이하 정밀한 값 표현
- 아주 크거나 작은 값은 부동 소수점 방식으로 표기
    - 가수지수
    - 예: 9조 4600억 = 9.46e12
    - 숫자 짧아지고 비교에도 용이함

---

**파이썬 구조와 데이터 처리**

**복소수형**

- 실수부 + 허수부
    - 알파벳 j 접미사가 복소수임을 나타냄

(코드 예시)

python

코드 복사

`a = 1+2j b = 3+4j print(a + b)`

출력: (4+6j)

---

**파이썬 구조와 데이터 처리**

**문자열(String)**

- 일련의 문자를 따옴표로 감싸 나열한 것
- 각종 문자, 기호, 숫자 등 포함 가능
- 따옴표는 따옴표 안에 적을 수 없음
    - 큰따옴표 포함하려면 작은따옴표로 감싸야 함

(코드 예시)

python

코드 복사

`a = "Korea 서울 1234" print(a)`

출력: Korea 서울 1234

---

**파이썬 구조와 데이터 처리**

**문자열(String)**

- 한 문자열에 두 따옴표 섞어 사용할 수 없음

(예시)

plaintext

코드 복사

`'I Say "Help" to you'`

---
**마무리 및 시사점**

- 파이썬 언어는 공유와 개방을 위해 최적화되어 있는 언어이다.
- 파이썬 언어는 사람 중심의 상위 수준의 언어이다.

---
**02 파이썬 및 필요 모듈 리뷰**  
**2. 연산자 및 조건문**

**학습개요**

- 파이썬의 연산자와 조건문에 대해서 알아본다.

**학습목표**

- 대입, 산술 연산자와 문자열, 정수, 실수 변환 연산자에 대해서 이해한다.
- 파이썬의 조건문, 논리 연산자, 블록 구조에 대해서 이해한다.

---

**연산자**

**대입 연산자**

- 변수에 값을 저장하는 연산자
- 변수 = 수식
    - 대입되는 값에 따라 변수 타입이 결정됨

(예시 코드)

python

코드 복사

`a = 3   s = 'korea'   f = 3.1415   a = (1 + 2) * 3   b = c * d + e`  

---

**연산자**

**산술 연산자**

- 사칙연산 수행하는 연산자

|연산자|설명|예|
|---|---|---|
|+|더하기|5 / 2 → 2.5|
|-|빼기|5 // 2 → 2|
|*|곱하기|7 % 2 → 1|
|/|나누기|8 % 3 → 2|
|**|거듭제곱|9 // 3 → 0|
|//|정수 나누기||
|%|나머지||

---

**연산자**

**복합 대입 연산자**

- 우변의 값이나 수식 계산하여 좌변에 대입

(예시 코드)

python

코드 복사

`a = 5   a = a + 1   print(a)`  

출력: 6

---
**연산자**

**복합 대입 연산자**

- `+=` 연산자: 좌변의 값에 우변의 값을 더함
- `-=` 연산자: 원래 값에서 일정 값을 뺌
- `*=` 연산자: 원래 값의 일정 배수 만듦

(예시 코드)

python

코드 복사

`a = 5 a += 1 print(a)  # 6`

---

**연산자**

**문자열 연산**

- `+` 와 `*` 연산자는 문자열에 대해서도 사용 가능
    - `+`: 문자열을 연결
    - `*`: 문자열을 정수 횟수만큼 반복

(예시 코드)

python

코드 복사

`s1 = "대한민국" s2 = "만세" print(s1 + s2)  # 대한민국만세 print("심심" * 5)  # 심심 심심 심심 심심 심심`

---

**연산자**

**정수와 문자열**

- `+` 연산자는 피연산자 타입 판별하여 숫자는 덧셈, 문자열은 연결함
    - 문자열과 숫자 섞어 더할 수 없음

(예시 코드)

python

코드 복사

`print("korea" + 2002)  # 에러 print("korea" + str(2002))  # korea2002`

---

**연산자**

**int 함수**

- 문자열을 숫자로 바꿀 때

(예시 코드)

python

코드 복사

`print(10 + int("22"))  # 32`

---

**연산자**

**실수의 변환**

- `float` 함수: 실수가 저장된 문자열을 실수로 변경

(예시 코드)

python

코드 복사

`print(10 + float("22.5"))  # 32.5 print(10 + float("314e-2"))  # 13.14`

---
**연산자**

**실수의 변환**

- 문자열에 저장된 실수를 정수로 바꾸는 경우
    - `float` 함수로 문자열을 실수로 변경
    - 다시 `int` 함수 사용하여 정수로 변경
- `round` 함수
    - 실수를 소수점 첫째 자리에서 반올림하여 정수 반환

---

**조건문**

**if문**

- 조건문: 조건의 진위 여부에 따라 명령 실행 여부 결정
- if 키워드로 조건문 작성

(예시 코드)

python

코드 복사

`age = int(input("너 몇 살이니?")) if age < 19:   print("애들은 가라")`

- 해당 조건이 참일 때만 명령어 실행
- 해당 조건이 거짓인 경우 무시하고 지나침
- 형식 규칙 지켜야 함

---

**조건문**

**비교 연산자**

- 두 값의 상등 여부나 대소관계 비교하여 참, 거짓 반환
- if문이 이 평가 결과에 따라 명령 실행 여부 결정

(연산자 설명)

text

코드 복사

`== : 같다 != : 다르다 <  : 좌변이 우변보다 작다 <= : 좌변이 우변보다 작거나 같다 >  : 좌변이 우변보다 크다 >= : 좌변이 우변보다 크거나 같다`

(예시 코드)

python

코드 복사

`if "39" > "59":   print("왼쪽") else:   print("오른쪽")`

---

**조건문**

**비교 연산자**

- 조건문에 비교 연산식 대신 변수 바로 쓸 수도 있음

(타입별 예시)

text

코드 복사

`값이 0인 숫자, 비어있지 않은 리스트, 비어 있지 않은 튜플`

(예시 코드)

python

코드 복사

`value = -1 if value:   print("참입니다.")`

---

**조건문**

**논리 연산자**

- 두 개 이상의 조건을 한꺼번에 점검하는 경우

(연산자 설명)

text

코드 복사

`and : 두 조건이 모두 참이다. 
or  : 두 조건 중 하나라도 참이다. 
not : 조건을 반대로 뒤집는다.`

(예시 코드)

python

코드 복사

`if a == 3 and b == 4:   print("OK")  
if a == 3 or b == 4:   print("OK")`

---
**조건문**

**블록 구조**

- 블록: 한꺼번에 실행되는 명령 묶음
    - 여러 명령이 하나의 조건에 함께 영향을 받음
    - 들여쓰기 틀려서 블록 구조 맞지 않으면 일부만 조건에 걸림

(예시 코드)

python

코드 복사

`age = 16 if age < 19:     print("애들은 가라")     print("공부 열심히 해야지")  age = 22 if age < 19:     print("애들은 가라")     print("공부 열심히 해야지")`

---

**조건문**

**else문**

- 같이 실행할 명령은 들여쓰기 맞추어 블록 구성하여야 함

(예시 코드)

python

코드 복사

`if age < 19:     print("애들은 가라")     print("공부 열심히 해야지") else:     print("어서 옵쇼")     print("놀 거면 시간 되세요")`

---

**조건문**

**elif문**

- else if
- if else 문에서 조건 만족하지 않을 때 세부 조건을 추가 점검

(예시 코드)

python

코드 복사

`age = 23 if age < 19:     print("애들은 가라") elif age < 25:     print("대학생입니다") else:     print("어서 옵쇼")`

- 살펴봐야 할 조건에 따라 얼마든지 elif문 넣을 수 있음

---

**마무리 및 시사점**

- 파이썬 언어는 실수, 정수, 문자열을 처리할 수 있는 언어이다.
- 파이썬 언어는 논리연산, 비교연산, 블록 처리를 할 수 있는 언어이다.
---
**02 파이썬 및 필요 모듈 리뷰**

**3. 반복문 및 함수**

---

**반복문**

**while 반복문**

- 조건이 만족하는 동안 명령을 계속 실행
- 루프(Loop)
    - 반복적으로 처리하는 명령

(예시 코드)

python

코드 복사

`student = 1 while student <= 5:     print(student, "번 학생의 성적을 처리합니다.")     student += 1`

(결과)

코드 복사

`1 번 학생의 성적을 처리합니다. 2 번 학생의 성적을 처리합니다. 3 번 학생의 성적을 처리합니다. 4 번 학생의 성적을 처리합니다. 5 번 학생의 성적을 처리합니다.`

(예시 코드 2)

python

코드 복사

`num = 1 sum = 0 while num <= 100:     sum += num     num += 1 print("sum =", sum)`

(결과)

bash

코드 복사

`sum = 5050`

---

**for 반복문**

- 컬렉션 요소 순서대로 반복하면서 루프 명령 실행

(예시 코드)

python

코드 복사

`for student in [1, 2, 3, 4, 5]:     print(student, "번 학생의 성적을 처리합니다.")`

---

**range 명령**

- 일정 범위 리스트 만들고 그 요소를 반복

(예시 코드)

python

코드 복사

`sum = 0 for num in range(1, 101):     sum += num print("sum =", sum)`

(결과)

bash

코드 복사

`sum = 5050`

---

**제어 변수의 활용**

- 루프의 반복 횟수와 끝낼 시점을 결정
- % 연산자: 배수(나머지가 0)를 판별

(예시 코드)

python

코드 복사

for x in range(1, 51):    
	if x % 10 == 0:         
		print("+", end = "")     
	else:         
		print("-", end = "")`

---
**반복문**

**break**

- 특정한 조건에 따라 루프를 끝내고 다음 명령으로 이동

(예시 코드)

python

코드 복사

`score = [92, 86, 68, 120, 56] for s in score:     if (s < 0 or s > 100):         break     print(s) print("성적 처리 끝")`

(실행 결과)

코드 복사

`92 86 68 성적 처리 끝`

---

**continue**

- 현재 실행 블록의 나머지를 건너뛰고, 루프 선두의 조건을 점검한 후 반복 재개

(예시 코드)

python

코드 복사

`score = [92, 86, 68, -1, 56] for s in score:     if (s == -1):         continue     print(s) print("성적 처리 끝")`

(실행 결과)

코드 복사

`92 86 68 56 성적 처리 끝`

---

**이중 루프**

- 루프 안 명령 자리에 또 다른 루프가 들어가 중첩된 것
- 이중 루프를 작성하는 경우에도 들여쓰기에 주의

(예시 코드)

python

코드 복사

`for dan in range(2, 10):     print(dan, "단")     for hang in range(2, 10):         print(dan, "*", hang, "=", dan * hang)`

(실행 결과)

python

코드 복사

`2 * 2 = 4 ... 9 * 9 = 81`

(while 루프 예시)

python

코드 복사

`dan = 2 while dan <= 9:     hang = 2     while hang <= 9:         print(dan, "*", hang, "=", dan * hang)         hang += 1     dan += 1`

---

**범위의 원칙**

- 컴퓨터에서 범위 설정할 때는 끝 요소를 제외하고 직전까지만 포함
- `range(1, 10)` = 1에서 9까지의 범위
    - 범위 구간 나누어 반복 처리할 때의 편의 위함

(표)

|일상생활에서의 범위|컴퓨터에서의 범위|
|---|---|
|1~10|0~10|
|11~20|10~20|
|21~30|20~30|
|31~40|30~40|
|41~50|40~50|

---
**반복문**

**오프셋**

- 기준에서의 상대적인 거리
- 0부터 시작

(이미지: 오프셋 예시)

---

**함수**

- 일련의 코드 블록에 이름을 붙여 정의한 것
- 자주 반복되는 코드 사용이 용이해짐
- 호출문으로 실행

(예시 코드)

python

코드 복사

`def calcsum(n):     sum = 0     for num in range(n + 1):         sum += num     return sum  print("~ 4 =", calcsum(4)) print("~ 10 =", calcsum(10))`

(실행 결과)

코드 복사

`~ 4 = 10 ~ 10 = 55`

---

**인수**

- 호출원에서 함수로 전달되는 작업거리
- 함수의 동작에 변화 주어 활용성 높임
- 매개변수
    - 형식 인수 = 함수 정의문의 인수
    - 실인수 = 함수 호출문에서 전달하는 인수
    - 리턴값 = 실행 결과를 호출원으로 돌려주는 값(없어도 무관)

(예시 코드)

python

코드 복사

`def calcange(begin, end):     sum = 0     for num in range(begin, end + 1):         sum += num     return sum  print("3 ~ 7 =", calcange(3, 7))`

(실행 결과)

코드 복사

`3 ~ 7 = 25`

---

**가변 인수**

- 고정되지 않은 임의 개수의 인수를 받음
- \ * 기호를 인수 이름 앞에 붙임

- 인수 목록의 마지막에 와야 함

`def intsum(*ints):     
	sum = 0     
	for num in ints:        
		sum += num     
	return sum  
print(intsum(1, 2, 3)) 
print(intsum(7, 9, 11, 13)) 
print(intsum(8, 9, 6, 2, 9, 7, 5, 8))`

`6 40 54`

---
이미지에 있는 파이썬 코드와 설명을 텍스트로 옮겨 적고, 코드의 실행 결과도 함께 정리해 보았습니다.

### 키워드 인수

- 인수 이름 지정하여 대입 형태로 전달하는 방식
- 앞쪽에 키워드 인수 있으면 뒤쪽에 위치 인수 올 수 없음

Python

```
def calcstep(begin, end, step=1):
    sum = 0
    for num in range(begin, end + 1, step):
        sum += num
    return sum

print("1~10:", calcstep(1, 10, 2))  
print("1~100:", calcstep(1, 100))  
   print("1~100:", calcstep(begin=1, end=100))  
# print("1~100:", calcstep(1, end=100))  # 오류 발생
```

코드를 사용할 때는 [주의](/faq#coding)가 필요합니다.

**실행 결과:**

```
1~10: 25
1~100: 5050
1~100: 5050
```

### 함수

**인수의 기본값**

- 잘 바뀌지 않는 인수는 기본값 지정
- 실인수 생략하면 기본값 전달

Python

```
def calcstep(begin, end, step=1):
    sum = 0
    for num in range(begin, end + 1, step):
        sum += num
    return sum

print("3~5:", calcstep(3, 5, 1))  
print("3~5:", calcstep(begin=3, end=5, step=1))  
print("3~5:", calcstep(step=1, end=5, begin=3))  
```

코드를 사용할 때는 [주의](/faq#coding)가 필요합니다.

**실행 결과:**

```
3~5: 12
3~5: 12
3~5: 12
```

### 키워드 가변 인수

- `**` 기호를 인수 목록에 붙여 키워드 인수를 가변 개수로 전달함
- 위치 인수와 키워드 인수를 동시에 가변으로 취할 수도 있음

Python

```
def calcstep(**args):
    begin = args['begin']
    end = args['end']
    step = args['step']
    sum = 0
    for num in range(begin, end + 1, step):
        sum += num
    return sum

print("3~5:", calcstep(begin=3, end=5, step   =1))  
```

코드를 사용할 때는 [주의](/faq#coding)가 필요합니다.

**실행 결과:**

```
3~5: 12
```
---
### 지역 변수

- 함수 내부에서 선언하는 변수
- 함수 내부에서만 사용되고 밖으로는 알려지지 않음

Python

```
def calcsum(n):
    sum = 0  # 지역 변수 초기화
    for num in range(n + 1):
        sum += num  # 누적
    return sum
```

코드를 사용할 때는 [주의](/faq#coding)가 필요합니다.

### 전역 변수

- 함수 바깥에서 선언하는 변수
- 어디에서나 참조할 수 있음

Python

```
global salerate  # 전역 변수 선언

salerate = 0.9

def kim():
    print("오늘의 할인율:", salerate)

def lee():
    price = 1000
    print("가격:", price * salerate)

kim()

salerate = 1.1  # 전역 변수 값 변경

lee()
```

코드를 사용할 때는 [주의](/faq#coding)가 필요합니다.

**실행 결과:**

```
오늘의 할인율: 0.9
가격: 1100.0
```

### 함수

**docstring**

- 함수 선언문과 본체 사이에 작성하는 문자열
- 함수의 사용법, 인수의 의미, 주의사항 등 설명 작성
- 실행에는 영향 없음

Python

```
def calcsum(n):
    """1~n까지의 합계를 구해 리턴한다."""  # docstring
    sum = 0
    for i in range(n+1):
        sum += i
    return sum

help(calcsum)  # docstring 출력
```

코드를 사용할 때는 [주의](/faq#coding)가 필요합니다.

**실행 결과:**

```
Help on function calcsum in module __main__:

calcsum(n)
    1~n까지의 합계를 구해 리턴한다.
```
---
### 마무리 및 시사점

- 파이썬 언어는 반복적인 수행을 효과적으로 처리하기 위한 방법을 제공한다.
- 파이썬 언어는 기능적으로 분리된 반복을 위해 함수를 사용한다.
---
### 02 파이썬 및 필요 모듈 리뷰

**4. 리스트와 튜플**

**(이미지)** 인공지능이란? 지능적인 에이전트를 만들려는 컴퓨터 과학의 한 분야이다. - John McCarthy

**학습개요**

- 파이썬의 기본 자료구조인 리스트와 튜플을 이해한다.

**학습목표**

- 파이썬 내부에서 처리하는 리스트와 이를 처리하는 방식을 이해한다.
- 튜플 자료 구조를 이해하고, 리스트와 튜플의 차이를 이해한다.

**리스트와 튜플**

- 자료의 집합
    - 리스트는 여러 개 값을 집합적으로 저장
- 요소(Element)
    - 리스트에 소속되는 각각의 값
    - 리스트에는 주로 같은 타입 요소를 모음

Python

```
score = [88, 95, 70, 100, 99]
name = ["최상미", "이한승", "김기남"]

list_acorn = [10, 20, 30]
score = [88, 95, 70, 100, 99]

for s in score:
    sum += s
print("총점:", sum)
print("평균:", sum/len(score))
```

코드를 사용할 때는 [주의](/faq#coding)가 필요합니다.

**실행 결과:**

```
총점: 452
평균: 90.4
```
---
### 리스트와 튜플

**리스트의 요소**

- 개별 요소 읽기: 대괄호 안에 읽고자 하는 요소의 순서값을 적음

Python

```
score = [88, 95, 70, 100, 99]

print(score[0])  # 88
score[0] = 78  # 78
print(score[0])  # 78
print(score[-1])  # 99
```

코드를 사용할 때는 [주의](/faq#coding)가 필요합니다.

**실행 결과:**

```
88
78
99
```

리스트에서 특정 요소에 접근하고 값을 변경하는 방법을 보여주고 있습니다. `score[0]`은 리스트 `score`의 첫 번째 요소(인덱스 0)에 접근하여 값을 가져오고, `score[0] = 78`은 첫 번째 요소의 값을 78로 변경합니다. `score[-1]`은 리스트의 마지막 요소에 접근하는 방법입니다.

### 리스트와 튜플

**리스트의 요소**

- 요소 분리: 범위 지정
    - `[begin:end:step]`

Python

```
nums = [-1, 1, 2, 3, 4, 5, 6, 7, 8, 9]

print(nums[2:5])  # 2~5
print(nums[4:])  # 처음부터 4까지
print(nums[:4])  # 4에서 끝까지
print(nums[1:7:2])  # 1~7까지 하나씩 건너뛰며
```

코드를 사용할 때는 [주의](/faq#coding)가 필요합니다.

**실행 결과:**

```
[2, 3, 4]
[4, 5, 6, 7, 8, 9]
[-1, 1, 2, 3]
[1, 3, 5]
```

리스트에서 여러 요소를 한 번에 분리하는 방법을 설명하고 있습니다. `nums[2:5]`는 인덱스 2부터 4까지의 요소를, `nums[4:]`는 인덱스 4부터 마지막 요소까지, `nums[:4]`는 처음부터 인덱스 3까지의 요소를 분리합니다. `nums[1:7:2]`는 인덱스 1부터 6까지 2칸씩 건너뛰며 요소를 분리합니다.

### 리스트와 튜플

**이중 리스트**

- 리스트의 요소로 리스트를 넣어 중첩할 수 있음

Python

```
lol = [[1, 2, 3], [4, 5], [6, 7, 8, 9]]

print(lol[0])  # [1, 2, 3]
print(lol[2][1])  # 7

for sub in lol:
    for item in sub:
        print(item, end='')
    print()
```

코드를 사용할 때는 [주의](/faq#coding)가 필요합니다.

**실행 결과:**

```
[1, 2, 3]
7
123
45
6789
```

리스트 안에 또 다른 리스트를 넣어 이중 리스트를 만드는 방법을 보여주고 있습니다. `lol[0]`은 이중 리스트 `lol`의 첫 번째 요소인 리스트 `[1, 2, 3]`을, `lol[2][1]`은 세 번째 요소인 리스트 `[6, 7, 8, 9]`의 두 번째 요소 7을 가져옵니다. 이중 for문을 사용하여 이중 리스트의 모든 요소를 출력하는 방법도 보여줍니다.

---
### 리스트와 튜플

**리스트 컴프리헨션(List Comprehension)**

- `[수식 for 변수 in 리스트 if 조건]`

Python

```
listcomp = [num * 2 for num in range(1, 11) if num % 2 == 0]
# for i in nums:
#     print(i, end=',')
print(listcomp)

nums = []
for n in range(1, 11):
    nums.append(n * 2)

print(nums)
```

코드를 사용할 때는 [주의](/faq#coding)가 필요합니다.

**실행 결과:**

```
[4, 8, 12, 16, 20]
[2, 4, 6, 8, 10, 12, 14, 16, 18, 20]
```

리스트 컴프리헨션을 사용하여 간결하게 리스트를 생성하는 방법을 보여주고 있습니다. 첫 번째 예제는 1부터 10까지의 짝수에 2를 곱한 값을 갖는 리스트를 생성합니다. 두 번째 예제는 1부터 10까지의 숫자에 2를 곱한 값을 갖는 리스트를 생성합니다. 리스트 컴프리헨션을 사용하면 for문과 if문을 사용하는 것보다 코드를 더 간결하게 작성할 수 있습니다.

### 리스트와 튜플

**리스트 컴프리헨션(List Comprehension)**

- 삽입
    - `append`: 인수로 전달한 요소를 리스트 끝에 추가
    - `insert`: 삽입할 위치와 요소값을 전달받아 리스트 중간에 삽입

Python

```
nums = [1, 2, 3, 4]

nums.append(5)
print(nums)  # [1, 2, 3, 4, 5]

nums.insert(2, 99)
print(nums)  # [1, 2, 99, 3, 4, 5]
```

코드를 사용할 때는 [주의](/faq#coding)가 필요합니다.

**실행 결과:**

```
[1, 2, 3, 4, 5]
[1, 2, 99, 3, 4, 5]
```

리스트에 요소를 추가하는 `append()`와 `insert()` 메서드를 설명하고 있습니다. `append(5)`는 리스트 `nums`의 끝에 5를 추가하고, `insert(2, 99)`는 인덱스 2의 위치에 99를 삽입합니다.

### 리스트와 튜플

**리스트 컴프리헨션(List Comprehension)**

- 삽입
    - 범위에 리스트 대입하여 여러 요소 한꺼번에 삽입 가능

Python

```
nums = [1, 2, 3, 4]

nums[2:2] = [90, 91, 92]
print(nums)  # [1, 2, 90, 91, 92, 3, 4]

nums = [1, 2, 3, 4]
nums[2] = [90, 91, 92]
print(nums)  # [1, 2, [90, 91, 92], 4]
```

코드를 사용할 때는 [주의](/faq#coding)가 필요합니다.

**실행 결과:**

```
[1, 2, 90, 91, 92, 3, 4]
[1, 2, [90, 91, 92], 4]
```

리스트의 특정 범위에 다른 리스트를 대입하여 여러 요소를 한 번에 삽입하는 방법을 보여주고 있습니다. `nums[2:2] = [90, 91, 92]`는 인덱스 2의 위치에 새로운 리스트 `[90, 91, 92]`를 삽입하고, `nums[2] = [90, 91, 92]`는 인덱스 2의 요소를 새로운 리스트로 대체합니다.

### 리스트와 튜플

**삭제**

- 대상 선택 방법에 따라 다른 메서드 사용
    
    - `remove`: 인수로 전달받은 요소값 찾아 삭제
    - `del`: 순서값 지정하여 삭제
    - `clear`: 리스트 모든 요소 삭제
    
- 빈 리스트 대입: 일정 범위 요소 다수 삭제

Python

```
score = [88, 95, 70, 100, 99, 80, 78, 5   8]

score.remove(100)
print(score)  # [88, 95, 70, 99, 80, 78, 58]

del(score[2])
print(score)  # [88, 95, 99, 80, 78, 58]

score[1:4] = []
print(score)  # [88, 78, 58]
```

코드를 사용할 때는 [주의](/faq#coding)가 필요합니다.

**실행 결과:**

```
[88, 95, 70, 99, 80, 78, 58]
[88, 95, 99, 80, 78, 58]
[88, 78, 58]
```

리스트에서 요소를 삭제하는 `remove()`, `del`, `clear()` 메서드와 빈 리스트를 대입하는 방법을 설명하고 있습니다. `remove(100)`은 리스트 `score`에서 값이 100인 요소를 삭제하고, `del(score[2])`는 인덱스 2의 요소를 삭제합니다. `score[1:4] = []`는 인덱스 1부터 3까지의 요소를 삭제합니다.

**리스트에서 요소를 삭제하는 방법들**

1. **remove**: 인수로 전달받은 요소값 찾아 삭제
    
    - 예시: `list.remove(3)`  
        리스트에서 첫 번째로 만나는 3을 삭제.
2. **del**: 순서값 지정하여 삭제
    
    - 예시: `del list[2]`  
        리스트의 세 번째 요소를 삭제.
3. **clear**: 리스트 모든 요소 삭제
    
    - 예시: `list.clear()`  
        리스트의 모든 요소를 삭제해 빈 리스트로 만듦.
4. **빈 리스트 대입**: 일정 범위 요소 다수 삭제
    
    - 예시: `list[1:3] = []`  
        리스트의 1번에서 2번 인덱스까지 요소를 삭제해 빈 리스트로 대체.

---
### 리스트와 튜플

**검색**

- `index`: 특정 요소 위치 찾음
- `count`: 특정 요소값의 개수 조사
- `min` / `max`: 리스트 요소 중 최소값 / 최대값 찾음
- `in` / `not in`: 특정 요소 유무 여부 검사

Python

```
score = [88, 95, 70, 100, 99, 88, 99, 88, 78]
perfect = score.index(100)  # 100점 위치
print("만점 받은 학생은 " + str(perfect) + "번입니다.")

pernum = score.count(100)
print("만점자 수는 " + str(pernum) + "명입니다")
```

코드를 사용할 때는 [주의](/faq#coding)가 필요합니다.

**실행 결과:**

```
만점 받은 학생은 3번입니다.
만점자 수는 1명입니다.
```

리스트에서 특정 요소를 검색하는 다양한 메서드를 설명하고 있습니다. `index(100)`은 리스트 `score`에서 값이 100인 요소의 인덱스를 반환하고, `count(100)`은 값이 100인 요소의 개수를 반환합니다.

### 리스트와 튜플

**정렬**

- 요소를 크기순으로 재배열
- `sort`: 리스트 정렬하며 요소 순서 조정, 리스트 자체 수정
- `reverse`: 요소 순서 반대로
- `key`: 정렬 시 요소 비교할 키 추출
- `sorted`: 리스트 그대로 두고 정렬된 새로운 리스트를 만들어 리턴

Python

```
score = [88, 95, 70, 100, 99]

score.sort()
print(score)  # [70, 88, 95, 99, 100]

score.reverse()
print(score)  # [100, 99, 95, 88, 70]
```

코드를 사용할 때는 [주의](/faq#coding)가 필요합니다.

**실행 결과:**

```
[70, 88, 95, 99, 100]
[100, 99, 95, 88, 70]
```

리스트의 요소를 정렬하는 `sort()`와 `reverse()` 메서드를 설명하고 있습니다. `sort()`는 리스트 `score`를 오름차순으로 정렬하고, `reverse()`는 리스트의 요소 순서를 반대로 뒤집습니다.

### 튜플

**튜플 자료형**

- 튜플은 초기화한 후 변경할 수 없다는 점에서 리스트와 차이
- 소괄호 사용하여 정의

Python

```
tuplescore = (88, 95, 70, 100, 99)

sum = 0
for s in tuplescore:
    sum += s

print("총점:", sum)
print("평균:", sum / len(tuplescore))
```

코드를 사용할 때는 [주의](/faq#coding)가 필요합니다.

**실행 결과:**

```
총점: 452
평균: 90.4
```

튜플을 정의하고 사용하는 방법을 보여주고 있습니다. 튜플은 리스트와 달리 요소를 변경할 수 없습니다. `tuplescore`는 튜플을 정의하는 예시이고, for문을 사용하여 튜플의 요소를 순회하고 합계와 평균을 계산합니다.

**튜플 자료형**

- `print`: 튜플 출력 시 소괄호 함께 출력하여 리스트 아님을 나타냄
- 정의할 때에는 소괄호 없이 값만 나열해도 무관함
---
### 리스트와 튜플

**튜플로 가능한 일**

- `+` / `*` 연산자 사용하여 연결 및 반복
- 요소 변경 불가능하니 유용한 속성 변경

Python

```
tu = (1, 2, 3, 4, 5)
tu2 = (6, 7)

print(tu + tu2)  # (1, 2, 3, 4, 5, 6, 7)
print(tu * 2)  # (1, 2, 3, 4, 5, 1, 2, 3, 4, 5)
# print(tu[1])  # 가능
# print(tu[1:4])  # 가능
# print(tu + (6, 7))  # 가능
# print(tu * 2)  # 가능
# tu[1] = 100  # 불가능
# del tu[1]  # 불가능
```

코드를 사용할 때는 [주의](/faq#coding)가 필요합니다.

**실행 결과:**

```
(1, 2, 3, 4, 5, 6, 7)
(1, 2, 3, 4, 5, 1, 2, 3, 4, 5)
```

튜플에서 `+` 연산자를 사용하여 두 튜플을 연결하고, `*` 연산자를 사용하여 튜플을 반복하는 방법을 보여주고 있습니다. 튜플은 요소를 변경할 수 없기 때문에 `tu[1] = 100`이나 `del tu[1]`과 같은 연산은 수행할 수 없습니다.

### 리스트와 튜플

**튜플로 가능한 일**

- 여러 개의 변수에 값을 한꺼번에 대입
- 좌변에 변수 목록, 우변에 튜플을 대입
    - unpacking

Python

```
tu = ("이순신", "김유신", "강감찬")
lee, kim, kang = tu  # unpacking
print(lee)
print(kim)
print(kang)
```

코드를 사용할 때는 [주의](/faq#coding)가 필요합니다.

**실행 결과:**

```
이순신
김유신
강감찬
```

튜플 unpacking을 사용하여 튜플의 요소를 여러 변수에 한 번에 할당하는 방법을 보여주고 있습니다. `lee, kim, kang = tu`는 튜플 `tu`의 요소들을 각각 변수 `lee`, `kim`, `kang`에 할당합니다.

### 리스트와 튜플

**튜플로 가능한 일**

- 두 개 이상 값을 반환
- 내부에 요소 포함하는 튜플 사용
- `divmod`: 나눗셈의 몫(`//`)과 나머지(`%`)를 튜플로 묶어 리턴

Python

```
def gettime():
    import time
    now = time.localtime()
    return now.tm_hour, now.tm_min  # 튜플 리턴

result = gettime()
print("지금은 %d시 %d분입니다." % (result[0], result[1]))
```

코드를 사용할 때는 [주의](/faq#coding)가 필요합니다.

**실행 결과:**

```
# 현재 시간에 따라 결과는 달라짐
# 예시: 지금은 20시 15분입니다.
```

함수에서 튜플을 사용하여 두 개 이상의 값을 반환하는 방법을 보여주고 있습니다. `gettime()` 함수는 현재 시간의 시와 분을 튜플로 묶어서 반환하고, `print()` 함수에서 튜플 unpacking을 사용하여 시와 분을 출력합니다.

### 마무리 및 시사점

- 파이썬 언어는 자료를 처리하기 위한 기본 구조로 리스트를 사용한다.
- 의미적인 표현을 위해서 튜플을 사용하고 활용한다.
---
### 02 파이썬 및 필요 모듈 리뷰

**5. 사전과 집합, 컬렉션 관리, 표준 모듈**

**(이미지)** 인공지능이란? 지능적인 에이전트를 만들려는 컴퓨터 과학의 한 분야이다. - John McCarthy

**학습개요**

- 파이썬에 데이터를 처리하는 고급 기능을 이해한다.

**학습목표**

- 사전, 집합, 컬렉션을 이해한다.
- 외부 기능을 활용하기 위한 표준 모듈 사용법을 이해한다.

### 사전과 집합

**사전(Dictionary)**

- 키와 값의 쌍을 저장하는 대용량 자료구조
- 맵 / 연관배열
- 중괄호 안에 키:값 형태로 콤마로 구분하여 나열

Python

```
dic = {'boy': '소년', 'school': '학교', 'book': '책'}
print(dic)
```

코드를 사용할 때는 [주의](/faq#coding)가 필요합니다.

**실행 결과:**

```
{'boy': '소년', 'school': '학교', 'book': '책'}
```

사전을 정의하고 출력하는 방법을 보여주고 있습니다. 사전은 키와 값의 쌍으로 이루어진 자료구조이며, 중괄호 `{}`를 사용하여 정의합니다.

### 사전과 집합

**사전(Dictionary)**

- 빠른 검색 가능
- 찾는 키가 없을 경우 예외 발생
    - 예외 처리 구문
    - `get` 메서드
- 특정 키 검색 시에는 `in` 구문 사용

Python

```
dic = {'boy': '소년', 'school': '학교', 'book': '책'}

print(dic['boy'])  # 소년
# print(dic['student'])  # 예외 발생: KeyError

print(dic.get('student'))  # None
print(dic.get('student', '사전에 없는 단어입니다.'))  # 사전에 없는 단어입니다.
```

코드를 사용할 때는 [주의](/faq#coding)가 필요합니다.

**실행 결과:**

```
소년
None
사전에 없는 단어입니다.
```

사전에서 값을 검색하는 방법과 키가 없을 때 예외를 처리하는 방법을 보여주고 있습니다. `dic['boy']`는 키 `'boy'`에 해당하는 값 `'소년'`을 반환합니다. 키가 존재하지 않으면 `KeyError` 예외가 발생하지만, `get()` 메서드를 사용하면 예외 대신 `None`을 반환하거나, 두 번째 인수로 지정한 기본값을 반환할 수 있습니다.

---
### 02 파이썬 및 필요 모듈 리뷰

#### 5. 사전과 집합, 컬렉션 관리, 표준 모듈

---

#### 학습개요

- 파이썬에 데이터를 처리하는 고급 기능을 이해한다.

#### 학습목표

- 사전, 집합, 컬렉션을 이해한다.
- 외부 기능을 활용하기 위한 표준 모듈 사용법을 이해한다.

---

### 사전과 집합

#### 사전(Dictionary)

- 키와 값의 쌍을 저장하는 대용량 자료구조
- 맵 / 연관배열
- 중괄호 안에 키:값 형태로 콤마로 구분하여 나열

bash

코드 복사

`dic = { 'boy':'소년', 'school':'학교', 'book':'책' } print(dic)`

설명결과: `{'book': '책', 'school': '학교', 'boy': '소년'}`

---

#### 사전(Dictionary)

- **빠른 검색 가능**

#### [키]

bash

코드 복사

`dic = { 'boy':'소년', 'school':'학교', 'book':'책' } print(dic['boy']) print(dic['book'])`

설명결과: `소년` `책`

---

#### 찾는 키가 없을 경우 예외 발생

- 예외 처리 구문
- `get` 메서드 사용 가능

bash

코드 복사

`dic = { 'boy':'소년', 'school':'학교', 'book':'책' } print(dic.get('student', '사전에 없는 단어입니다.'))`

설명결과: `None` (사전에 없는 단어입니다.)

---

###### 특정 키 검색 시에는 `in` 구문 사용

---
### 사전과 집합

**사전 관리**

- 실행 중 삽입, 삭제, 수정 등 편집 가능
- 사전[키]
    - 키의 존재 여부에 따라 동작 다름
        - 존재할 경우: 기존 값의 변경
        - 존재하지 않을 경우: 키/값 추가
![[Pasted image 20241006224012.png|300]]
**(이미지)** 사전에 키/값 쌍을 추가하는 과정을 그림으로 보여줌

### 사전과 집합

**사전 관리**

- del
    
    - 해당 키를 찾아 값과 함께 삭제
    
- keys / values 메서드
    
    - 사전의 키/값 목록 얻음
    

Python

```
dic = {'boy': '소년', 'school': '학교', 'book': '책'}

print(dic.keys())
print(dic.values())
print(dic.items())
```

코드를 사용할 때는 [주의](/faq#coding)가 필요합니다.

**실행 결과:**  

```
dict_keys(['boy', 'school', 'book'])
dict_values(['소년', '학교', '책'])
dict_items([('boy', '소년'), ('school', '학교'), ('book', '책')])
```

### 사전과 집합

**사전 관리**

- dict_\* 객체
    - 리스트처럼 순회하여 값 순서대로 읽음
- update 메서드
    - 두 개 사전을 병합
- dict 함수
    - 빈 사전 만들거나 다른 자료형을 사전으로 변환

Python

```
dic = {'boy': '소년', 'school': '학교', 'book': '책'}

# update 메서드
dic.update(student='학생')
print(dic)

# dict 함수
dic2 = dict(zip(['boy', 'school', 'book'], ['소년', '학교', '책']))
print(dic2)
```

코드를 사용할 때는 [주의](/faq#coding)가 필요합니다.

**실행 결과:**

```
{'boy': '소년', 'school': '학교', 'book': '책', 'student': '학생'}
{'boy': '소년', 'school': '학교', 'book': '책'}
```
---
### 사전과 집합

---

#### 사전 관리

- 실행 중 삽입, 삭제, 수정 등 편집 가능

css

코드 복사

`dicchange = { 'boy':'소년', 'school':'학교', 'book':'책' } dic['boy'] = '남자애' dic['girl'] = '소녀' del(dic['book']) print(dic)`

설명결과: `{'boy': '남자애', 'girl': '소녀', 'school': '학교'}`

---

#### 사전[키]

- 키의 존재 여부에 따라 동작 다름
    - 존재할 경우: 기존 값의 변경
    - 존재하지 않을 경우: 키를 추가

bash

코드 복사

`dic['boy'] = '남자애'  # 수정 dic['girl'] = '소녀'   # 추가`

---

#### 사전 관리 - `del`

- 해당 키를 찾아 값과 함께 삭제

#### keys / values 메서드

- 사전의 키 / 값 목록 얻음

scss

코드 복사

`dic = { 'boy':'소년', 'school':'학교', 'book':'책' } print(dic.keys()) print(dic.values()) print(dic.items())`

설명결과:

css

코드 복사

`dict_keys(['book', 'boy', 'school']) dict_values(['책', '소년', '학교']) dict_items([('book', '책'), ('boy', '소년'), ('school', '학교')])`

---

#### 사전 관리 - `dict_*` 객체

- 리스트처럼 순회하여 값 순서대로 읽음

bash

코드 복사

`dic = { 'boy':'소년', 'school':'학교', 'book':'책' } keylist = dic.keys() for key in keylist:     print(key)`

설명결과:

코드 복사

`boy school book`

---

#### update 메서드

- 두 개 사전을 병합

---

#### dict 함수

- 빈 사전 만들거나 다른 자료형을 사전으로 변환
---
### 사전과 집합

---

#### 집합 정의

- 여러 가지 값의 모임

bash

코드 복사

`set = { 'korea', 'china', 'japan', 'korea' } print(set)`

설명결과: `{'korea', 'china', 'japan'}`

---

#### set() 함수

- 빈 집합 만들거나 다른 컬렉션을 집합형으로 변환
- 인수 없이 `set()` 함수 호출 → 공집합 만들기

python

코드 복사

`print(set("sanghyun")) print(set([1, 34, 56, 78])) print(set(("서울", "대전", "일산"))) print(set({'boy':'남자', 'school':'학교', 'book':'책'})) print(set())`

설명결과:

bash

코드 복사

`{'u', 'n', 'a', 'h', 'g', 's', 'y'} {56, 34, 12, 78} {'일산', '서울', '대전'} {'boy', 'school', 'book'} set()`

---

#### 집합 정의

- add 메서드: 집합에 원소 추가
- update 메서드: 집합끼리 결합하여 합집합 만들기 (중복 허용되지 않음에 유의)

---

#### 집합 연산

- 연산을 통한 집합 간 조합

|연산|기호|메서드|설명|
|---|---|---|---|
|합집합|∪|`union`|두 집합의 모든 원소|
|교집합|∩|`intersection`|두 집합에 모두 있는 원소|
|차집합|-|`difference`|왼쪽 집합에만 있는 원소|
|대칭 차집합|△|`symmetric_difference`|한쪽 집합에만 있는 원소의 합|
|부분집합|≤|`issubset`|원소의 오른쪽이 부분집합인지 조사|
|진부분집합|<|-|부분집합이면서 여분의 원소가 더 있음|
|포함집합|≥|`issuperset`|원소의 오른쪽 집합을 포함하는지 조사|
|진상 포함집합|>|-|포함집합이면서 여분의 원소가 더 있음|

bash

코드 복사

`tmax = { 2, 4, 6, 8, 10, 12 } threex = { 3, 6, 9, 12, 15 }  print("합집합", tmax | threex) print("교집합", tmax & threex) print("차집합", tmax - threex) print("대칭 차집합", tmax ^ threex)`

설명결과:

코드 복사

`합집합 {2, 3, 4, 6, 8, 9, 10, 12, 15} 교집합 {12, 6} 차집합 {8, 2, 10, 4} 대칭 차집합 {2, 3, 4, 8, 9, 10, 15}`

---
### 컬렉션 관리

---

#### enumerate

- 순서값과 요소값을 한꺼번에 구하는 내장함수
- 여러 학생의 성적을 출력할 경우 for문 이용
    - 순서값을 알 수 없음
    - 별도 변수를 활용한 복잡한 과정을 통해 순서값 구함

css

코드 복사

`score = [88, 95, 70, 100, 99] for s in score:     print("성적 :", s)  score = [88, 95, 70, 100, 99] for no in range(len(score)):     print(str(no + 1) + "번 학생의 성적 :", score[no])`

---

#### zip

- 여러 개 컬렉션 합쳐 하나로 만듦
- 두 리스트의 대응되는 요소끼리 짝지어 튜플 리스트 생성

css

코드 복사

`yoil = ["월", "화", "수", "목", "금", "토", "일"] food = ["갈비탕", "순대국", "탕수육", "삼겹살"]  menu = zip(yoil, food)  for y, f in menu:     print("%s요일 메뉴: %s" % (y, f))`

설명결과:

코드 복사

`월요일 메뉴: 갈비탕 화요일 메뉴: 순대국 수요일 메뉴: 탕수육 목요일 메뉴: 삼겹살`

- 합쳐지는 두 리스트의 길이는 무관
- 생성되는 튜플의 순서는 원본 리스트의 순서와 같음

---

#### filter 함수

- 리스트 요소 중 조건에 맞는 것만을 골라냄
- 첫 번째 인수: 조건 지정하는 함수
- 두 번째 인수: 대상 리스트

python

코드 복사

`def flunk(s):     return s < 60  score = [45, 89, 72, 53, 94] for s in filter(flunk, score):     print(s)`

설명결과:

코드 복사

`45 53`

- `flunk` 함수: 점수 `s`를 인수 받아 60 미만인지 조사
- 
---
### 컬렉션 관리

#### map 함수

- 모든 요소에 대한 변환함수 호출, 새 요소값으로 구성된 리스트 생성
- 인수 구조는 filter 함수와 동일

python

코드 복사

`def half(s):     return s / 2  score = [45, 89, 72, 53, 94] for s in map(half, score):     print(s, end = ', ')`

설명결과:

코드 복사

`22.5, 44.5, 36.0, 26.5, 47.0,`

- half 함수: 인수로 전달받은 s를 절반으로 나누어 리턴

---

#### 람다 함수

- 이름 없고 입력과 출력만으로 함수 정의하는 축약된 방법
- `lambda` 인수:식
    - 인수는 여러 개 가질 수 있음

python

코드 복사

`lambda x: x + 1`

scss

코드 복사

`score = [45, 89, 72, 53, 94] for s in filter(lambda x: x < 60, score):     print(s)`

---

#### 리스트의 사본

- 기본형 변수는 대입 이후 둘 중 하나 바꾸어도 다른 쪽에 영향 없음
- 컬렉션의 경우, 같은 리스트를 두 변수가 가리키는 것이라 영향 있음

css

코드 복사

`a = 3 b = a print("a = %d, b = %d" % (a, b))  a = 5 print("a = %d, b = %d" % (a, b))`

설명결과:

css

코드 복사

`a = 3, b = 3 a = 5, b = 3`

scss

코드 복사

`list1 = [1, 2, 3] list2 = list1  list2[2] = 100 print(list1) print(list2)`

설명결과:

csharp

코드 복사

`[1, 2, 100] [1, 2, 100]`

---
### 컬렉션 관리

#### 리스트의 사본

- `copy` 메서드로 두 리스트를 완전히 독립 사본으로 만들 수 있음

scss

코드 복사

`list1 = [1, 2, 3] list2 = list1.copy()  list2[2] = 100 print(list1) print(list2)`

설명결과:

csharp

코드 복사

`[1, 2, 3] [1, 100, 3]`

- `list[:]`로 전체 범위에 대한 사본 만드는 방법도 가능

---

#### 리스트의 사본 (deepcopy)

scss

코드 복사

`list0 = ['a', 'b'] list1 = [list0, 1, 2] list2 = list1.copy()  list2[0][1] = 'c' print(list1) print(list2)`

설명결과:

css

코드 복사

`[['a', 'c'], 1, 2] [['a', 'c'], 1, 2]`

scss

코드 복사

`import copy  list0 = ['a', 'b'] list1 = [list0, 1, 2] list2 = copy.deepcopy(list1)  list2[0][1] = 'c' print(list1) print(list2)`

설명결과:

css

코드 복사

`[['a', 'b'], 1, 2] [['a', 'c'], 1, 2]`

---

#### is 연산자

- `is` 구문 통해 두 변수가 같은 객체 가리키는지 조사

python

코드 복사

`list1 = [1, 2, 3] list2 = list1 list3 = list1.copy()  print("1 == 2", list1 is list2) print("1 == 3", list1 is list3) print("2 == 3", list2 is list3)`

설명결과:

graphql

코드 복사

`1 == 2 True 1 == 3 False 2 == 3 False`
![[Pasted image 20241006224803.png|400]]

---
### 표준 모듈

#### import 명령

- **외부의 모듈을 가져와 사용**
    - 필요 기능에 따라 선택
- **파이썬에는 자주 사용하는 기능이 표준 모듈로 함께 설치되어 있음**
    - math 모듈에 작성된 모든 상수와 함수를 가져옴

lua

코드 복사

`import math print(math.sqrt(2))`

**실행 결과**:

코드 복사

`1.4142135623730951`

---

#### import 명령

- **from 모듈 import 함수명**
    - 모듈의 함수 호출
    - 이 경우 `sqrt` 외 `math`에 속한 다른 함수는 사용할 수 없음

lua

코드 복사

`from math import sqrt print(sqrt(2))`

---

#### math 모듈

- **상수**:
    - pi : 원주율, tau : 2*pi, e : 자연 대수, inf : 무한대, nan : 숫자 아님

| 함수                        | 설명                                                        |
| ------------------------- | --------------------------------------------------------- |
| sqrt(x)                   | x의 제곱근을 구한다. 체제공률은 1/3승을 계산하여 구한다.                        |
| pow(x, y)                 | x의 y승을 계산한다. **연산자와 기능은 같지만 인수를 모두 실수로 변환 후 연산한다는 차이가 있다. |
| hypot(x, y)               | 피타고라스 정리에 의거 x제곱 + y제곱의 제곱근을 구한다.                         |
| sin(x), cos(x), tan(x)    | 삼각함수를 계산한다. 인수는 라디안 값이다.                                  |
| asin(x), acos(x), atan(x) | 역삼각함수를 계산한다. 인수는 라디안 값이다.                                 |
| sinh(x), cosh(x)          | 쌍곡선 삼각함수를 계산한다. 인수는 라디안 값이다.                              |
| tanh(x)                   | 쌍곡선 탄젠트를 계산한다. 인수는 라디안 값이다.                               |
| degrees(x)                | 라디안 값을 각도로 바꾼다.                                           |
|radians(x)|각도 값을 라디안 값으로 바꾼다.|

---
### math 모듈

- **상수**: pi : 원주율, tau : 2*pi, e : 자연 대수, inf : 무한대, nan : 숫자 아님

|함수|설명|
|---|---|
|ceil(x)|수직선 오른쪽의 올림 값을 찾는다.|
|floor(x)|수직선 왼쪽의 내림 값을 찾는다.|
|fabs(x)|x의 절대값을 구한다.|
|trunc(x)|x의 소수점 이하를 버린다.|
|log(x, base)|base에 대한 x의 로그를 구한다. base가 생략되면 자연 로그를 구한다.|
|log10(x)|10의 로그를 구한다. log(x, 10)과 같다.|
|gcd(a, b)|a, b의 최대공약수를 구한다.|

---

### time 모듈

- 날짜와 시간 관련 기능 제공
- 에폭(Epoch) / 유닉스 시간

**예시**:

lua

코드 복사

`import time print(time.time())`

**실행 결과**:

코드 복사

`1515549457.5692239`

lua

코드 복사

`import time t = time.time() print(time.ctime(t))`

**실행 결과**:

yaml

코드 복사

`Wed Jan 10 10:58:24 2018`

lua

코드 복사

`import time start = time.time() for a in range(1000):     print(a) end = time.time() print(end - start)`

---

### calendar 모듈

- **달력 기능**
    - 인수로 받은 연도의 달력 객체 반환
- **month 함수**
    - 연도와 달을 인수로 받아 해당 월 달력 객체 반환
- **weekday 함수**
    - 특정 날짜가 어떤 요일인지 조사

**예시**:

scss

코드 복사

`import calendar print(calendar.calendar(2018)) print(calendar.month(2019, 1)) #calendar.prcal(2018) #calendar.prmonth(2019, 1)`

---
### random 모듈

- **난수 생성 기능**

#### randint(begin, end)

- 일정 범위의 정수 난수 범위 설정

#### randrange(begin, end)

- end는 범위에서 제외

#### choice 함수

- 리스트에서 임의의 요소 하나 골라 반환

---

### random 모듈 (계속)

#### shuffle 함수

- 리스트의 요소 무작위로 섞음

scss

코드 복사

`import random food = ["짜장면", "짬뽕", "탕수육", "군만두"] print(food) random.shuffle(food) print(food)`

**실행 결과**:

css

코드 복사

`['짜장면', '짬뽕', '탕수육', '군만두'] ['군만두', '짬뽕', '탕수육', '짜장면']`

#### sample 함수

- 리스트 항목 중 n개를 무작위로 뽑아 새 리스트 만듬

---

### sys 모듈

- 파이썬 해석기가 실행되는 환경과 해석기의 여러 기능 조회 및 관리

**예시**:

lua

코드 복사

`import sys print("버전 :", sys.version) print("플랫폼 :", sys.platform) if sys.platform == "win32":     print(sys.getwindowsversion()) print("바이트 순서 :", sys.byteorder) print("모듈 경로 :", sys.path) sys.exit(0)`

**실행 결과**:

less

코드 복사

`버전 : 3.6.2 (v3.6.2:5fd33b5, Jul 8 2017, 04:14:34) [MSC v.1900 32 bit (Intel)] 플랫폼 : win32 (10, 0, 0, 15063, 'Multiprocessor Free') 바이트 순서 : little 모듈 경로 : ['C:\\Python36\\lib\\site-packages']`

---

### 마무리 및 시사점

- 파이썬 언어는 고급 데이터 처리를 위해 사전, 집합, 컬렉션을 제공한다.
- 파이썬 언어는 외부 기능을 활용하기 위한 표준 모듈을 제공한다.
- 
---
### 파일 및 클래스

#### 학습 개요

- 파이썬 언어의 파일 처리 방식과 객체 선언에 대해 이해한다.

#### 학습 목표

- 파이썬에서 파일을 읽고, 쓰고, 처리하는 방식을 이해한다.
- 파이썬에서 클래스를 선언하고, 멤버 함수를 호출하는 방법을 이해한다.

---

### 파일 (File)

- **정보를 저장하는 기본 단위**
    - 문서, 이미지, 멀티미디어 자료 등을 모두 보관

#### 파일 오픈

- **파일 입력** 준비 및 파일 객체 반환
- **파일 사용 후 close 메서드로 닫기**
- **open(파일 경로, 모드)**

|모드|설명|
|---|---|
|r|파일을 읽는다. 파일이 없으면 예외가 발생한다.|
|w|파일에 기록한다. 파일이 이미 있으면 덮어쓴다.|
|a|파일에 데이터를 추가한다.|
|x|파일을 새로 만들어 쓴다. 파일이 있으면 실패한다.|

**예시**:

swift

코드 복사

`f = open("live.txt", "wt") f.write("삶이 그대를 속일지라도\n슬퍼하거나 노하지 말라!\n우울한 날을 견디면\n믿어라, 기쁨의 날이 오리니") f.close()`

---
### 파일 읽기

#### read 함수

python

코드 복사

`try:     f = open("live.txt", "rt")     text = f.read()     print(text) except FileNotFoundError:     print("파일이 없습니다.") finally:     f.close()`

---

### 파일 읽기

#### readline 함수

- 한 줄씩 읽기
- 파일 마지막에 빈 문자열 반환

arduino

코드 복사

`f = open("live.txt", "rt") text = "" line = 1 while True:     row = f.readline()     if not row: break     text += str(line) + " : " + row     line += 1 f.close() print(text)`

---

### 파일 관리 함수

|함수|설명|
|---|---|
|shutil.copy(a, b)|파일을 복사한다.|
|shutil.copytree(a, b)|디렉토리를 복사한다. 서브 디렉토리까지 전부 복사한다.|
|shutil.move(a, b)|파일을 이동한다.|
|shutil.rmtree(path)|디렉토리를 삭제한다.|
|os.rename(a, b)|이름을 변경한다.|
|os.remove(f)|파일을 삭제한다.|
|os.chmod(f, m)|파일의 퍼미션을 변경한다.|
|shutil.chown(f, u, g)|파일의 소유권을 변경한다.|
|os.link(a, b)|하드 링크를 생성한다.|
|os.symlink(a, b)|심볼릭 링크를 생성한다.|

go

코드 복사

`import shutil shutil.copy("live.txt", "live2.txt")`

---

### 디렉토리 관리 함수

|함수|설명|
|---|---|
|os.chdir(d)|현재 디렉토리를 변경한다.|
|os.mkdir(d)|디렉토리를 생성한다.|
|os.rmdir(d)|디렉토리를 제거한다.|
|os.getcwd()|현재 디렉토리를 조사한다.|
|os.listdir(d)|디렉토리의 내용을 나열한다.|
|glob.glob(p)|패턴과 일치하는 파일의 목록을 나열한다.|

|함수|설명|
|---|---|
|os.path.isabs(f)|절대 경로인지 조사한다.|
|os.path.abspath(f)|파일의 절대 경로를 구한다.|
|os.path.realpath(f)|파일의 실제 경로를 구한다.|
|os.path.exists(f)|파일의 존재 여부를 조사한다.|
|os.path.isfile(f)|파일인지 조사한다.|
|os.path.isdir(f)|디렉토리인지 조사한다.|
### 클래스 (Class)

- 객체지향의 가장 기본적 개념
- 관련된 속성과 동작을 하나의 범주로 묶어 실제 세계의 사물을 흉내냄

---

### 클래스

- **모델링**: 사물 분석하여 필요한 속성과 동작을 추출
- **캡슐화**: 모델링 결과를 클래스로 포장
- **멤버**: 클래스 구성하는 변수와 함수
- **메서드**: 클래스에 소속된 함수

---

### 생성자

#### __init__ 생성자

- 초기값으로 멤버 변수를 초기화
- 객체 생성 시 첫 번째 인수로 `self` 전달
- 생성문에서 전달한 인수는 두 번째 이후의 인수로 전달

ruby

코드 복사

`class Human:     def __init__(self, age, name):         self.age = age         self.name = name     def intro(self):         print(str(self.age) + "살 " + self.name + "입니다.")  kim = Human(29, "김상형") kim.intro()`

---

### 상속

- 기존 클래스를 확장하여 멤버 추가하거나 동작 변경
- 클래스 이름 다음의 괄호 안에 부모 클래스 이름 지정

python

코드 복사

`class Human:     def __init__(self, age, name):         self.age = age         self.name = name     def intro(self):         print(str(self.age) + "살 " + self.name + "입니다.")  class Student(Human):     def __init__(self, age, name, stunum):         super().__init__(age, name)         self.stunum = stunum     def intro(self):         super().intro()         print("학번: " + str(self.stunum))     def study(self):         print("하늘천 따지 공부중")  lee = Student(34, "이상형", 930011) lee.intro() lee.study()`

---
### 클래스 (Class)

- **객체지향**의 가장 기본적 개념
- 관련된 **속성**과 **동작**을 하나의 범주로 묶어 **실세계의 사물**을 흉내냄

---

### 클래스

#### 모델링

- 사물 분석하여 필요한 **속성**과 **동작** 추출

#### 캡슐화

- **모델링** 결과를 **클래스**로 포장

#### 멤버

- **클래스**를 구성하는 **변수**와 **함수**

#### 메서드

- **클래스**에 소속된 **함수**

---

### 생성자

#### __init__ 생성자

- **초기값**으로 멤버변수를 초기화

#### 객체 생성

- __init__의 첫 번째 인수 **self**로 전달
- 생성문에서 전달한 인수를 두 번째 이후의 인수로 전달

##### 코드 예시:

python

코드 복사

`class Human:     def __init__(self, age, name):         self.age = age         self.name = name         print(str(self.age) + "살 " + self.name + " 입니다.")`

##### 객체 생성 예시:

python

코드 복사

`kim = Human(29, "김상형")`

****init**** 함수에서 age와 name이 **self**로 전달됨.

### 클래스

#### 상속

- 기존 **클래스** 확장하여 멤버 추가하거나 동작 변경
- 클래스 이름 다음의 괄호 안에 **부모 클래스** 이름 지정

##### 코드 예시:

python

코드 복사

`class Human:     def __init__(self, age, name):         self.age = age         self.name = name          def intro(self):         print(str(self.age) + "살 " + self.name + " 입니다.")  class Student(Human):     def __init__(self, age, name, stunum):         super().__init__(age, name)         self.stunum = stunum      def intro(self):         super().intro()         print("학번: " + str(self.stunum))      def study(self):         print("열심히 공부 중입니다.")`

##### 객체 생성 예시:

python

코드 복사

`kim = Human(29, "김상형") kim.intro()  lee = Student(34, "이승우", 930811) lee.intro() lee.study()`

출력 결과:

makefile

코드 복사

`29살 김상형입니다. 34살 이승우입니다. 학번: 930811 열심히 공부 중입니다.`

---

### 클래스

#### super() 메서드

- **자식 클래스**에서 **부모**의 메서드를 호출할 때 사용

---

### 클래스

#### 액세서

- 파이썬 클래스의 멤버는 모두 **공개**되어 누구나 외부에서 액세스 가능
- 일정한 **규칙** 마련하여 안전한 액세스 보장

#### 게터(Getter) 메서드

- 멤버 값 대신 읽음

#### 세터(Setter) 메서드

- 멤버 값 변경

##### 코드 예시:

python

코드 복사

`class Date:     def __init__(self, month):         self.setMonth(month)          def getMonth(self):         return self._month          def setMonth(self, month):         if 1 <= month <= 12:             self._month = month         else:             self._month = 1  today = Date(8) today.setMonth(15) print(today.getMonth())`

출력 결과:

코드 복사

`8`

### 클래스

#### 액세서

- 특정 객체에 대한 작업 처리가 아닌 **클래스 전체에 공유**
- **@classmethod** 데코레이터
- 첫 번째 인수로 클래스에 해당하는 **cls** 인수

##### 코드 예시:

python

코드 복사

`class Car:     count = 0     def __init__(self, name):         self.name = name         Car.count += 1      @classmethod     def outcount(cls):         print(cls.count)  pride = Car("프라이드") Korando = Car("코란도") Car.outcount()`

출력 결과:

코드 복사

`2`

---

### 클래스

#### 정적 메서드

- 클래스에 포함되는 **단순 유틸리티 메서드**
- 특정 객체에 소속되거나 클래스 관련 동작 하지 않음
- **@staticmethod** 데코레이터

##### 코드 예시:

python

코드 복사

`class Car:     @staticmethod     def hello():         print("오늘도 안전 운행 합시다.")      count = 0     def __init__(self, name):         self.name = name         Car.count += 1      @classmethod     def outcount(cls):         print(cls.count)  Car.hello()`

출력 결과:

코드 복사

`오늘도 안전 운행 합시다.`

---

### 클래스

#### 연산자 메서드

- **연산자** 사용하여 객체끼리 연산
- **연산자 오버로딩**: 클래스별로 연산자 동작을 고유하게 정의

##### 코드 예시:

python

코드 복사

`class Human:     def __init__(self, age, name):         self.age = age         self.name = name      def __eq__(self, other):         return self.age == other.age and self.name == other.name  kim = Human(29, "김상형") sang = Human(29, "김상형") moon = Human(44, "문상형")  print(kim == sang) print(kim == moon)`

출력 결과:

graphql

코드 복사

`True False`

##### 연산자 오버로딩 메서드 예시:

| 연산자 | 메서드            | 우항의 매칭 메서드      |
| --- | -------------- | --------------- |
| ==  | `__eq__`       |                 |
| !=  | `__ne__`       |                 |
| <   | `__lt__`       |                 |
| >   | `__gt__`       |                 |
| <=  | `__le__`       |                 |
| >=  | `__ge__`       |                 |
| +   | `__add__`      | `__radd__`      |
| -   | `__sub__`      | `__rsub__`      |
| *   | `__mul__`      | `__rmul__`      |
| /   | `__truediv__`  | `__rtruediv__`  |
| //  | `__floordiv__` | `__rfloordiv__` |
| %   | `__mod__`      | `__rmod__`      |
| **  | `__pow__`      | `__rpow__`      |
| <<  | `__lshift__`   | `__rlshift__`   |
| >>  | `__rshift__`   | `__rrshift__`   |
|     |                |                 |
|     |                |                 |

### 클래스

#### 특수 메서드

- 특정한 구문에 객체 사용될 경우 미리 약속된 작업 수행

|메서드|설명|
|---|---|
|__str__|str(객체) 형식으로 객체를 문자열화한다.|
|__repr__|repr(객체) 형식으로 객체의 표현식을 만든다.|
|__len__|len(객체) 형식으로 객체의 길이를 조사한다.|

##### 코드 예시:

python

코드 복사

`class Human:     def __init__(self, age, name):         self.age = age         self.name = name      def __str__(self):         return "%s 쯤, 나이 %d" % (self.name, self.age)  kim = Human(29, "김상형") print(kim)`

출력 결과:

코드 복사

`이름 김상형, 나이 29`

---

### Decimal

- 정수 혹은 문자열 실수로 초기화
- 오류 없이 정확하게 **10진 실수**를 표현
    - 컴퓨터에서 이진 실수로 십진 실수를 정확하게 표현하기 어려움

##### float 연산 예시:

python

코드 복사

`f = 0.1 sum = 0 for i in range(100):     sum += f print(sum)`

출력 결과:

코드 복사

`9.999999999999998`

##### Decimal 연산 예시:

python

코드 복사

`from decimal import Decimal  f = Decimal('0.1') sum = 0 for i in range(100):     sum += f print(sum)`

출력 결과:

코드 복사

`10.0`

---

### Decimal

#### 실수형과는 연산할 수 없음

#### Context 객체

- 연산 수행 **방법**을 지정
- `getcontext` / `setcontext` 함수로 **컨텍스트 변경**
- 같은 연산이라도 **컨텍스트**에 따라 결과가 다를 수 있음

|컨텍스트|설명|
|---|---|
|BasicContext|유효 자릿수 9, ROUND_HALF_UP 반올림 처리|
|ExtendedContext|유효 자릿수 9, ROUND_HALF_EVEN 반올림 처리|
|DefaultContext|유효 자릿수 28, ROUND_HALF_EVEN 반올림 처리|
### Fraction

- **유리수**를 표현
- 분모와 분자를 따로 전달하여 **분수 형태** 숫자 표현함

##### 코드 예시:

python

코드 복사

`from fractions import Fraction  a = Fraction(1, 3) print(a) b = Fraction(8, 14) print(b)`

출력 결과:

코드 복사

`1/3 4/7`

---

### array 모듈

- 동일 타입 집합인 **배열**을 지원
- 대량 자료를 **메모리 낭비 없이** 저장 및 **고속 액세스** 가능

python

코드 복사

`array(타입코드, [초기값])`

|타입|C타입코드|설명|
|---|---|---|
|b, B|char|1바이트의 정수|
|u||2바이트의 유니코드 문자(3.3이후 지원 안함)|
|h, H|short|2바이트의 정수|
|i, I|int|4바이트의 정수|
|l, L|long|4바이트의 정수|
|q, Q|long long|8바이트의 정수(3.3이상에서만 지원)|
|f|float|4바이트의 실수|
|d|double|8바이트의 실수|

---

### 마무리 및 시사점

- 파이썬에서 **장기간의 데이터 처리**를 위해 **파일 구조**를 지원한다.
- 파이썬 언어는 **객체를 선언**하고 **사용**할 수 있는 **객체지향 언어**이다.


### 02. 파이썬 및 필요 모듈 리뷰

- **7. Numpy, Pandas, Matplotlib**

---

### 학습 개요

- 파이썬에서 자주 사용하는 **외부 라이브러리**를 읽고 사용하는 방법을 이해한다.

---

### 학습 목표

- **수치 연산**에 특화된 **Numpy** 라이브러리의 특성과 사용 방법을 이해한다.
- **데이터 분석**에 특화된 **Pandas** 라이브러리의 특성과 사용 방법을 이해한다.
- **시각화**에 특화된 **Matplotlib** 라이브러리의 특성과 사용 방법을 이해한다.

---

### Numpy

- **Numerical Python**의 줄임말
- Numpy는 **벡터 및 행렬 연산**에 있어서 매우 편리한 기능을 제공
- 데이터 분석 라이브러리인 **Pandas**와 **Matplotlib**의 **기반**으로 사용됨
- 기본적으로 **array(행렬 개념)**라는 단위로 데이터를 관리

### Numpy 라이브러리

#### 설치

- `pip install numpy`
- **코랩(Colab)**을 사용한다면 기본적으로 설치되어 있음

---

#### 사용

- 라이브러리를 불러올 때는 `import`문을 사용
- `import numpy as np` # Numpy 라이브러리를 **np**라는 이름으로 호출

---

### Numpy 라이브러리

#### import numpy as np

##### 2차원 배열

python

코드 복사

`a = np.array([[0,1,2,3],[4,5,6,7],[8,9,10,11]]) print(a) print(a.ndim, a.shape, a.size)`

출력 결과:

lua

코드 복사

`array([[ 0,  1,  2,  3],        [ 4,  5,  6,  7],        [ 8,  9, 10, 11]]) (2, (3, 4), 12)`

---

##### 3차원 배열

python

코드 복사

`a = np.array([[[0,1,2,3],[4,5,6,7],[8,9,10,11]],               [[12,13,14,15],[16,17,18,19],[20,21,22,23]]]) print(a) print(a.ndim, a.shape, a.size)`

출력 결과:

lua

코드 복사

`array([[[ 0,  1,  2,  3],         [ 4,  5,  6,  7],         [ 8,  9, 10, 11]],         [[12, 13, 14, 15],         [16, 17, 18, 19],         [20, 21, 22, 23]]]) (3, (2, 3, 4), 24)`

### Numpy 라이브러리

#### import numpy as np

##### `numpy.arange(시작값, 끝값, 증감분)`

python

코드 복사

`a = np.arange(0, 1, 0.1) print(a)`

출력 결과:

scss

코드 복사

`array([0. , 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9])`

##### `numpy.zeros()`

- **0으로 채워진** 배열 만들기

python

코드 복사

`a = np.zeros((2, 3)) print(a)`

출력 결과:

lua

코드 복사

`array([[0., 0., 0.],        [0., 0., 0.]])`

---

### Numpy 라이브러리

#### import numpy as np

##### `numpy.ones()`

- **1으로 채워진** 배열 만들기

python

코드 복사

`a = np.ones((2, 3)) print(a)`

출력 결과:

lua

코드 복사

`array([[1., 1., 1.],        [1., 1., 1.]])`

##### `numpy.random.rand(개수)`

- 0과 1 사이의 **무작위 수**로 채워진 1차원 배열 만들기

python

코드 복사

`a = np.random.rand(3) print(a)`

출력 결과:

scss

코드 복사

`array([0.18064732, 0.87430527, 0.8516824])`

---

### Numpy 라이브러리

#### import numpy as np

##### `numpy.random.normal(평균, 표준편차, 개수)`

- 정규분포를 가지며 지정된 **평균**과 **표준편차**를 갖는 1차원 배열 만들기

python

코드 복사

`a = np.random.normal(1, 2, 10) print(a)`

출력 결과:

scss

코드 복사

`array([ 0.05516345,  2.32779704, -1.14642303,  2.85079415, -0.72164179,         0.10923538,  1.90112646, -1.9953345 ,  1.73222982, -3.35887609])`

##### `numpy.random.randint(시작값, 끝값, 개수)`

- 시작값과 끝값 사이의 무작위 **정수**를 갖는 1차원 배열 만들기

python

코드 복사

`a = np.random.randint(0, 10, 5) print(a)`

출력 결과:

scss

코드 복사

`array([7, 9, 1, 8, 5])`

다음과 같이 해당 슬라이드를 정리해줄게.

---

### Pandas

- 링크
- 데이터 **조작 및 분석**을 위한 라이브러리
- **시리즈(Series, 1차원 배열)**, **데이터프레임(DataFrame, 2차원 배열)** 지원

---

### Pandas 라이브러리

#### 설치

- `pip install pandas`
- **코랩(Colab)**에는 기본적으로 설치되어 있음

---

### 사용

- 라이브러리를 불러올 때에는 `import`문을 사용
- `import pandas as pd` # pd라는 이름으로 호출

---

### Pandas 라이브러리

#### 시리즈(Series)

- **1차원 배열**의 형태
- 딕셔너리(dictionary), 리스트(list), 튜플(tuple)을 **Series**로 처리

##### 코드 예시:

python

코드 복사

`import pandas as pd 
import matplotlib.pyplot as plt  
a = {'key1': 10, 'key2': 20, 'key3': 30, 'key4': 40} 
s = pd.Series(a)
plt.plot(s)
plt.show() 
print(s)`

출력 결과:

go

코드 복사

`key1    10 key2    20 key3    30 key4    40 dtype: int64`


### Pandas 라이브러리

#### 시리즈(Series)

##### 리스트를 시리즈로 변환

python

코드 복사

`a = ['string', 100, True] s = pd.Series(a) print(s)`

출력 결과:

vbnet

코드 복사

`0    string 1       100 2      True dtype: object`

##### 시리즈에 인덱스 추가

python

코드 복사

`s = pd.Series(a, index=['문자열', '정수값', '참거짓']) print(s)`

출력 결과:

vbnet

코드 복사

`문자열    string 정수값       100 참거짓      True dtype: object`

##### 튜플을 시리즈로 변환

python

코드 복사

`a = ('string', 100, True) s = pd.Series(a) print(s)`

출력 결과:

vbnet

코드 복사

`0    string 1       100 2      True dtype: object`

---

### Pandas 라이브러리

#### 데이터프레임(DataFrame)

- **2차원 배열**의 형태
- 여러 개의 **시리즈(Series)**를 모아 놓은 형태
- **엑셀**이나 관계형 **데이터베이스** 등에 사용

##### 데이터프레임 생성

python

코드 복사

`import pandas as pd  a = {'col0': [0, 1, 2], 'col1': [3, 4, 5], 'col2': [6, 7, 8]} df = pd.DataFrame(a) print(df)`

출력 결과:

코드 복사

   `col0  col1  col2 0     0     3     6 1     1     4     7 2     2     5     8`

##### 데이터프레임 인덱스 및 컬럼 설정

python

코드 복사

`df = pd.DataFrame([[1, 100, 'A'], [2, 200, 'B']], index=['ABC', 'DEF'], columns=['번호', '점수', '반']) print(df)`

출력 결과:

css

코드 복사

     `번호   점수  반 ABC   1   100   A DEF   2   200   B`

---

### 데이터프레임 수정

##### 열 이름 변경

python

코드 복사

`df.rename(columns={'점수': '신청'}, inplace=True) print(df)`

출력 결과:

css

코드 복사

     `번호   신청  반 ABC   1   100   A DEF   2   200   B`

##### 인덱스 이름 변경

python

코드 복사

`df.rename(index={'ABC': '가나다', 'DEF': '라마바'}, inplace=True) print(df)`

출력 결과:

css

코드 복사

     `번호   신청  반 가나다   1   100   A 라마바   2   200   B`

##### 행(row) 삭제

python

코드 복사

`df.drop(['가나다'], axis=0, inplace=True) print(df)`

출력 결과:

css

코드 복사

     `번호   신청  반 라마바   2   200   B`

##### 열(column) 삭제

python

코드 복사

`df.drop(['신청', '반'], axis=1, inplace=True) print(df)`

출력 결과:

markdown

코드 복사

     `번호 라마바   2`

### Pandas 라이브러리

#### 데이터프레임 행과 열 선택/추가/변경

|구분|`loc`|`iloc`|
|---|---|---|
|대상|인덱스 이름 (index label)|정수형 위치 인덱스 (integer position)|
|범위|범위의 끝을 포함|범위의 끝을 제외|

##### 예시 코드:

python

코드 복사

`import pandas as pd  a = {'타임A': [90, 89, 93], '타임B': [83, 74, 85], '타임C': [86, 97, 74]} df = pd.DataFrame(a, index=['P1', 'P2', 'P3']) print(df)`

출력 결과:

css

코드 복사

   `타임A  타임B  타임C P1    90    83    86 P2    89    74    97 P3    93    85    74`

---

#### 데이터프레임 행과 열 선택/추가/변경

##### `iloc`을 사용한 선택

python

코드 복사

`print(df.iloc[1:3])`

출력 결과:

css

코드 복사

   `타임A  타임B  타임C P2    89    74    97 P3    93    85    74`

##### 열 선택

python

코드 복사

`print(df['타임A'])`

출력 결과:

yaml

코드 복사

`P1    90 P2    89 P3    93 Name: 타임A, dtype: int64`

##### 행, 열 동시 선택

python

코드 복사

`print(df.iloc[[0,2], [0,1]])`

출력 결과:

css

코드 복사

   `타임A  타임B P1    90    83 P3    93    85`

---

#### 데이터프레임 열 추가/값 변경

##### 열 추가

python

코드 복사

`df['타임D'] = 0 print(df)`

출력 결과:

css

코드 복사

   `타임A  타임B  타임C  타임D P1    90    83    86     0 P2    89    74    97     0 P3    93    85    74     0`

##### 행 추가

python

코드 복사

`df.loc['P4'] = [81, 91, 95, 84] print(df)`

출력 결과:

css

코드 복사

   `타임A  타임B  타임C  타임D P1    90    83    86     0 P2    89    74    97     0 P3    93    85    74     0 P4    81    91    95    84`

##### 값 변경

python

코드 복사

`df.loc['P4', '타임A'] = 100 print(df)`

출력 결과:

css

코드 복사

   `타임A  타임B  타임C  타임D P1    90    83    86     0 P2    89    74    97     0 P3    93    85    74     0 P4   100    91    95    84`

---

### Pandas 라이브러리

#### 데이터 분석용 함수

|함수|기능|
|---|---|
|`count`|전체 성분의 (NaN이 아닌) 값의 개수|
|`min`, `max`|최소값, 최대값|
|`argmin`, `argmax`|최소값, 최대값이 위치한 인덱스 (정수)|
|`idxmin`, `idxmax`|인덱스 중 최소값, 최대값|
|`quantile`|특정 사분위수에 해당하는 값을 반환 (0~1 사이)|
|`sum`|합|
|`mean`|평균|
|`median`|중간값|
|`mad`|평균값과의 절대 편차(Absolute Deviation)의 평균|
|`std`, `var`|표준편차, 분산|
|`+`, `-`, `*`, `/`|사칙연산|

---

### Pandas 라이브러리

#### 데이터 분석용 함수 예시

##### 열 삭제

python

코드 복사

`df.drop(['타임D'], axis=1, inplace=True) print(df)`

출력 결과:

css

코드 복사

   `타임A  타임B  타임C P1    90    83    86 P2    89    74    97 P3    93    85    74 P4   100    91    95`

##### 행 방향 합계

python

코드 복사

`print(df.sum(axis=1))`

출력 결과:

go

코드 복사

`P1    259 P2    260 P3    252 P4    286 dtype: int64`

##### 열 방향 합계

python

코드 복사

`print(df.sum(axis=0))`

출력 결과:

css

코드 복사

`타임A    372 타임B    333 타임C    352 dtype: int64`

##### 평균 구하기

python

코드 복사

`print(df.mean())`

출력 결과:

css

코드 복사

`타임A    93.00 타임B    83.25 타임C    88.00 dtype: float64`

---

### Pandas 라이브러리

#### 데이터 분석용 함수 예시 (사칙연산)

##### 열간 차이 계산

python

코드 복사

`df['A-B'] = df['타임A'] - df['타임B'] print(df)`

출력 결과:

css

코드 복사

   `타임A  타임B  타임C  A-B P1    90    83    86     7 P2    89    74    97    15 P3    93    85    74     8 P4   100    91    95     9`

##### 열간 곱 계산

python

코드 복사

`df['A*B'] = df['타임A'] * df['타임B'] print(df)`

출력 결과:

css

코드 복사

   `타임A  타임B  타임C  A-B   A*B P1    90    83    86     7   7470 P2    89    74    97    15   6586 P3    93    85    74     8   7905 P4   100    91    95     9   9100`

### Pandas 라이브러리

#### CSV 파일 사용

##### CSV 파일 읽기

python

코드 복사

`cs = pd.read_csv("E:\\WW\\엑셀csv자료.csv", index_col=0, header=0, encoding='euc-kr') print(cs)`

출력 결과:

css

코드 복사

   `타임A  타임B  타임C  A-B   A*B P1    90    83    86     7   7470 P2    89    74    97    15   6586 P3    93    85    74     8   7905 P4   100    91    95     9   9100`

##### 정렬하기

python

코드 복사

`cs.sort_values(['A*B', 'A-B'], ascending=False, inplace=True) print(cs)`

출력 결과:

css

코드 복사

   `타임A  타임B  타임C  A-B   A*B P4   100    91    95     9   9100 P3    93    85    74     8   7905 P1    90    83    86     7   7470 P2    89    74    97    15   6586`

---

### Pandas 라이브러리

#### CSV 파일 사용

##### 열 추가 및 계산

python

코드 복사

`cs['A/B'] = cs['타임A'] / cs['타임B'] print(cs)`

출력 결과:

css

코드 복사

   `타임A  타임B  타임C  A-B   A*B      A/B P1    90    83    86     7   7470  1.084337 P2    89    74    97    15   6586  1.202703 P3    93    85    74     8   7905  1.094118 P4   100    91    95     9   9100  1.098901`

##### CSV 파일 저장

python

코드 복사

`cs.to_csv("E:\\WW\\엑셀csv자료수정.csv", mode='w', encoding='euc-kr')`


### Matplotlib

- [링크](https://matplotlib.org)
- 데이터를 **시각화**할 때 사용하는 라이브러리
- **2D형태의 그래프**, 이미지 등을 그릴 때 사용

---

### Matplotlib 라이브러리

#### 설치

- `python -m pip install -U matplotlib`
- 코랩(Colab)에는 기본적으로 설치되어 있음

---

### 사용

- 라이브러리를 불러올 때에는 `import`문을 사용
- `import matplotlib.pyplot as plt` # plt라는 이름으로 호출

---

### Matplotlib 라이브러리

#### import matplotlib.pyplot as plt

##### `matplotlib.plot(데이터 셋)`

- 1차원 배열 데이터로 **그래프 그리기**

python

코드 복사

`plt.plot([10, 20, 30, 40]) plt.show()`

---

##### `matplotlib.plot(x 축 데이터 셋, y 축 데이터 셋)`

python

코드 복사

`plt.plot([10, 20, 30, 40], [10, 20, 30, 40]) plt.show()`

### Matplotlib 라이브러리

#### import matplotlib.pyplot as plt

##### 제목 추가

python

코드 복사

`plt.title('Can you see the title?')`

##### 그래프 그리기 (x 축, y 축 데이터 셋, 범례)

python

코드 복사

`plt.plot([15, 20, 25, 30], [10, 20, 30, 40], label='First Group') plt.plot([15, 20, 25, 30], [40, 30, 20, 10], label='Second Group') plt.legend()  # 범례 표시 plt.show()`

---

### Matplotlib 라이브러리

#### import matplotlib.pyplot as plt

##### 그래프 색상과 선 모양 변경하기

python

코드 복사

`plt.title('Can you see the title?') plt.plot([10, 20, 30, 40], 'bo:', label='First Group')  # 파란색 점선 plt.plot([40, 30, 20, 10], 'rv--', label='Second Group')  # 빨간색 점선 plt.legend() plt.show()`

|Character|Color|Description|
|---|---|---|
|'b'|blue|파란색|
|'r'|red|빨간색|
|'g'|green|초록색|

|Character|Description|
|---|---|
|'--'|점선|
|'-'|실선|
|':'|도트 선|

### 마무리 및 시사점

- 파이썬 언어는 외부의 특화된 라이브러리를 지원한다.
- 파이썬 언어는 목적에 따라 **Numpy**, **Pandas**, **Matplotlib** 등을 활용할 수 있다.

# 5주차 - 머신러닝

머신 러닝 진행 개요
![[Pasted image 20241005201628.png|500]]
머신 러닝 학습 과정
![[Pasted image 20241005201713.png|500]]

Classification - 여러개의 결과값 중 하나를 선택
회귀 - 결과값 하나를 추론하느 ㄴ문제

### 손실 함수
최적의 가중치인 (W, b)를 찾는 것

#### 거리 측정
거리는 -면 안됨 -> Non-negativity
거리는 반대로 측정해도 같아야함. -> Symmetry
두 점 사이의 거리는 다른 점에서 갔다온 것 보다 무조건 짧아야 -> Triangle Inequality
![[Pasted image 20241005202705.png|300]]

L1 Norm - 1차원적으로 구한 길이, 가로 세로만 서로 뺀겨
L2 Norm - 실제 거리
Max Norm - L1 중에 가장 긴 것
Lp Norm - L2에서 p 만큼 제곱이 확장 됨.(p =3d이면 ^3)
![[Pasted image 20241005202854.png|400]]

L1 < L2 < L3(Lp인데 p가 3)
L2를 가장 많이 씀

MAE (제곱 없음)
![[Pasted image 20241005203116.png|400]]
MSE
![[Pasted image 20241005203139.png|400]]

소프트맥스 할 때는 크로스 엔트로피
![[Pasted image 20241005203211.png|400]]

### 최적화
경사하강법
![[Pasted image 20241005203349.png|400]]
Gradient : 변화율이 가장 큰 방향

### Keras
특징:
- 동일한 코드로 GPU와 CPU에서 실행 가능
- 사용하기 쉬운 API, 모델 프로토타입 빠르게 제작 가능
- CNN, RNN
- 다중입력, 다중 출력, 다양한 모델 공유 가능


